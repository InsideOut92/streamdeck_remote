<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>StreamDeck Remote</title>

  <link rel="manifest" href="/manifest.webmanifest" />
  <meta name="theme-color" content="#101821" />

  <style>
    :root {
      --bg0: #05101a;
      --bg1: #0d1f2f;
      --bg2: #133a54;
      --card: rgba(9, 20, 33, 0.74);
      --line: rgba(189, 220, 255, 0.23);
      --lineStrong: rgba(189, 220, 255, 0.4);
      --text: rgba(239, 249, 255, 0.98);
      --muted: rgba(205, 227, 246, 0.78);
      --ok: #22c55e;
      --warn: #f59e0b;
      --err: #ef4444;
      --accent: #5dd8ff;
      --radius: 18px;
      --shadow: 0 24px 60px rgba(0, 0, 0, 0.45);
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }

    body {
      margin: 0;
      color: var(--text);
      font-family: "Segoe UI Variable", "Segoe UI", "Noto Sans", sans-serif;
      background:
        radial-gradient(1200px 620px at 8% 3%, rgba(59,130,246,.22), transparent 63%),
        radial-gradient(1200px 650px at 90% 4%, rgba(14,165,233,.2), transparent 62%),
        linear-gradient(170deg, var(--bg0), var(--bg1) 46%, var(--bg2));
    }

    .app {
      min-height: 100%;
      padding: 14px;
      display: grid;
      place-items: start center;
    }

    .panel {
      width: min(1280px, 100%);
      border: 1px solid var(--line);
      border-radius: calc(var(--radius) + 8px);
      background: var(--card);
      backdrop-filter: blur(16px);
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    header {
      padding: 14px;
      display: grid;
      gap: 12px;
      border-bottom: 1px solid var(--line);
      background: linear-gradient(180deg, rgba(146, 201, 255, 0.16), rgba(30, 54, 74, 0.28));
    }

    .headTop {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 14px;
      flex-wrap: wrap;
    }

    .brand {
      display: grid;
      gap: 5px;
    }

    .brand strong { font-size: 18px; letter-spacing: .2px; }
    .brand span { font-size: 12px; color: var(--muted); }

    .headActions {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    .chip {
      border: 1px solid var(--line);
      background: rgba(2, 10, 17, 0.42);
      padding: 9px 12px;
      border-radius: 999px;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      color: rgba(228, 244, 255, 0.96);
      font-size: 12px;
      min-height: 38px;
    }

    .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--warn);
      box-shadow: 0 0 0 3px rgba(245, 158, 11, 0.2);
    }

    .dot.ok { background: var(--ok); box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.2); }
    .dot.err { background: var(--err); box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.2); }

    .btn {
      border: 1px solid var(--line);
      border-radius: 12px;
      background: rgba(193, 226, 255, 0.1);
      color: var(--text);
      padding: 10px 14px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      min-height: 42px;
      touch-action: manipulation;
    }
    .btn:focus-visible,
    .tab:focus-visible,
    .tile:focus-visible,
    .search input:focus-visible,
    .quickProgram input:focus-visible,
    .row input:focus-visible,
    .row select:focus-visible {
      outline: 2px solid rgba(93, 216, 255, 0.85);
      outline-offset: 2px;
    }

    .btn.primary {
      border-color: rgba(93, 216, 255, 0.62);
      background: linear-gradient(180deg, rgba(93, 216, 255, 0.28), rgba(93, 216, 255, 0.1));
    }
    .btn.warn { border-color: rgba(245, 158, 11, 0.45); }
    .btn.danger { border-color: rgba(239, 68, 68, 0.5); }

    .toolbar {
      display: grid;
      gap: 10px;
    }

    .topMenu {
      display: grid;
      gap: 10px;
      grid-template-columns: minmax(260px, 1fr) minmax(260px, 1fr);
    }

    .quickProgram {
      border: 1px solid var(--line);
      background: rgba(1, 9, 15, 0.4);
      border-radius: 16px;
      padding: 8px;
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .quickProgram input {
      width: 100%;
      border: 0;
      background: transparent;
      color: var(--text);
      outline: 0;
      padding: 8px;
      font-size: 13px;
    }

    .tabs {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .tab {
      border: 1px solid var(--line);
      background: rgba(0, 0, 0, 0.33);
      color: var(--text);
      border-radius: 999px;
      padding: 10px 13px;
      font-size: 13px;
      min-height: 42px;
      cursor: pointer;
      opacity: 0.88;
    }

    .tab[aria-selected="true"] {
      opacity: 1;
      border-color: var(--lineStrong);
      background: rgba(208, 233, 255, 0.2);
    }

    .searchRow {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
    }

    .search {
      display: flex;
      align-items: center;
      gap: 8px;
      min-width: min(520px, 100%);
      border: 1px solid var(--line);
      background: rgba(0, 0, 0, 0.34);
      border-radius: 999px;
      padding: 8px 11px;
    }

    .search input {
      width: 100%;
      border: 0;
      outline: 0;
      color: var(--text);
      background: transparent;
      font-size: 13px;
    }

    .content {
      padding: 14px;
      display: grid;
      gap: 14px;
    }

    .section {
      border: 1px solid var(--line);
      border-radius: var(--radius);
      overflow: hidden;
      background: rgba(255, 255, 255, 0.05);
    }

    .section h2 {
      margin: 0;
      padding: 10px 12px;
      font-size: 13px;
      color: var(--muted);
      border-bottom: 1px solid var(--line);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .grid {
      padding: 14px;
      display: grid;
      gap: 14px;
      grid-template-columns: repeat(auto-fit, minmax(210px, 1fr));
    }

    .tile {
      --typeTint: rgba(93, 216, 255, 0.45);
      border: 1px solid var(--line);
      border-radius: 16px;
      background: linear-gradient(180deg, rgba(233, 245, 255, 0.18), rgba(177, 214, 246, 0.08));
      color: var(--text);
      min-height: 102px;
      padding: 14px;
      display: grid;
      grid-template-columns: 44px 1fr;
      gap: 11px;
      align-items: center;
      text-align: left;
      cursor: pointer;
      position: relative;
      box-shadow: 0 10px 24px rgba(0,0,0,.26);
      transition: transform .1s ease, border-color .1s ease;
    }
    .tile::before {
      content: "";
      position: absolute;
      left: 0;
      top: 10px;
      bottom: 10px;
      width: 4px;
      border-radius: 0 999px 999px 0;
      background: linear-gradient(180deg, rgba(255,255,255,.2), var(--typeTint));
    }
    .tile[data-type="app"] { --typeTint: rgba(34, 211, 238, 0.8); }
    .tile[data-type="folder"] { --typeTint: rgba(251, 191, 36, 0.82); }
    .tile[data-type="url"] { --typeTint: rgba(59, 130, 246, 0.82); }
    .tile[data-type="protocol"] { --typeTint: rgba(192, 132, 252, 0.82); }
    .tile[data-type="action"] { --typeTint: rgba(16, 185, 129, 0.82); }

    .tile:hover { transform: translateY(-1px); border-color: rgba(255,255,255,.32); }
    .tile:active { transform: scale(.99); }
    .tile[disabled] { opacity: .58; cursor: not-allowed; }

    .iconWrap {
      width: 44px;
      height: 44px;
      border-radius: 12px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.22);
      display: grid;
      place-items: center;
      overflow: hidden;
      font-size: 21px;
    }

    .iconWrap img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .meta strong {
      display: block;
      font-size: 14px;
    }

    .meta {
      min-width: 0;
    }

    .metaTop {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 8px;
    }

    .metaTop strong {
      flex: 1 1 auto;
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .typePill {
      border: 1px solid rgba(255,255,255,.22);
      border-radius: 999px;
      padding: 2px 6px;
      font-size: 9px;
      font-weight: 700;
      letter-spacing: .4px;
      color: rgba(233, 246, 255, 0.9);
      background: rgba(2, 10, 17, 0.46);
      white-space: nowrap;
      flex: 0 0 auto;
      max-width: 72px;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .meta span {
      display: block;
      margin-top: 4px;
      font-size: 12px;
      color: var(--muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .fav {
      position: absolute;
      right: 9px;
      top: 8px;
      font-size: 11px;
      opacity: .95;
    }

    .empty {
      padding: 28px;
      text-align: center;
      color: var(--muted);
      font-size: 13px;
    }

    .toast {
      position: fixed;
      right: 12px;
      bottom: 12px;
      max-width: min(540px, calc(100vw - 24px));
      background: rgba(0,0,0,.62);
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 12px;
      opacity: 0;
      transform: translateY(8px);
      transition: opacity .16s ease, transform .16s ease;
      pointer-events: none;
      word-break: break-word;
    }

    .toast.show { opacity: 1; transform: translateY(0); }

    dialog {
      border: 1px solid var(--line);
      border-radius: 14px;
      background: rgba(11, 16, 26, 0.98);
      color: var(--text);
      width: min(760px, calc(100vw - 20px));
      max-height: min(90vh, 860px);
      overflow: auto;
      padding: 12px;
    }

    dialog::backdrop { background: rgba(0,0,0,.58); }

    #dlgOverlay {
      width: min(1320px, calc(100vw - 12px));
      max-height: min(94vh, 980px);
      padding: 0;
      overflow: hidden;
      background: rgba(8, 14, 23, 0.98);
      border-radius: 16px;
    }

    .overlayShell {
      display: grid;
      grid-template-rows: auto 1fr;
      min-height: min(90vh, 920px);
      max-height: min(90vh, 920px);
    }

    .overlayHead {
      border-bottom: 1px solid var(--line);
      padding: 10px 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      background: linear-gradient(180deg, rgba(132, 198, 255, 0.16), rgba(25, 41, 61, 0.32));
    }

    .overlayTitleWrap {
      display: grid;
      gap: 2px;
    }

    .overlayTitleWrap strong {
      font-size: 15px;
      letter-spacing: .2px;
    }

    .overlayTitleWrap span {
      font-size: 12px;
      color: var(--muted);
    }

    .overlayActions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .overlayFrameWrap {
      min-height: 0;
      background: rgba(4, 10, 18, 0.85);
    }

    #overlayFrame {
      width: 100%;
      height: 100%;
      border: 0;
      display: block;
      background: #050b13;
    }

    .dlgTitle { font-weight: 600; margin-bottom: 4px; }
    .dlgHint { color: var(--muted); font-size: 12px; margin-bottom: 8px; }

    .row {
      display: flex;
      gap: 9px;
      flex-wrap: wrap;
      align-items: center;
      margin: 9px 0;
    }

    .row > * { flex: 1; min-width: 180px; }

    .row input,
    .row select {
      width: 100%;
      border: 1px solid var(--line);
      border-radius: 10px;
      background: rgba(0,0,0,.24);
      color: var(--text);
      padding: 10px;
      outline: 0;
      font-size: 13px;
      touch-action: manipulation;
    }

    .inlineField {
      display: grid;
      gap: 6px;
      min-width: 180px;
      flex: 1;
    }

    .fieldStatus {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(205, 227, 246, 0.32);
      font-size: 11px;
      line-height: 1;
      color: rgba(222, 239, 255, 0.92);
      background: rgba(0, 0, 0, 0.24);
      width: fit-content;
      max-width: 100%;
    }

    .fieldStatus::before {
      content: "";
      width: 7px;
      height: 7px;
      border-radius: 50%;
      background: rgba(156, 193, 224, 0.92);
      box-shadow: 0 0 0 2px rgba(156, 193, 224, 0.22);
      flex: 0 0 auto;
    }

    .fieldStatus.ok {
      border-color: rgba(34, 197, 94, 0.55);
      color: rgba(203, 255, 223, 0.96);
      background: rgba(34, 197, 94, 0.12);
    }
    .fieldStatus.ok::before {
      background: rgba(34, 197, 94, 0.96);
      box-shadow: 0 0 0 2px rgba(34, 197, 94, 0.22);
    }

    .fieldStatus.warn {
      border-color: rgba(245, 158, 11, 0.56);
      color: rgba(255, 234, 193, 0.98);
      background: rgba(245, 158, 11, 0.12);
    }
    .fieldStatus.warn::before {
      background: rgba(245, 158, 11, 0.96);
      box-shadow: 0 0 0 2px rgba(245, 158, 11, 0.22);
    }

    .fieldStatus.err {
      border-color: rgba(239, 68, 68, 0.56);
      color: rgba(255, 214, 214, 0.98);
      background: rgba(239, 68, 68, 0.12);
    }
    .fieldStatus.err::before {
      background: rgba(239, 68, 68, 0.96);
      box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.22);
    }

    .fieldStatus.info {
      border-color: rgba(93, 216, 255, 0.52);
      color: rgba(220, 247, 255, 0.95);
      background: rgba(93, 216, 255, 0.11);
    }
    .fieldStatus.info::before {
      background: rgba(93, 216, 255, 0.95);
      box-shadow: 0 0 0 2px rgba(93, 216, 255, 0.2);
    }

    .settingsStickyBar {
      display: none;
    }

    .rowActions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      margin-top: 10px;
      flex-wrap: wrap;
    }

    .setGroup {
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px;
      margin-top: 10px;
      background: rgba(0,0,0,.18);
      display: grid;
      gap: 8px;
    }

    .setRow {
      border: 1px solid rgba(255,255,255,.1);
      border-radius: 10px;
      padding: 8px;
      display: grid;
      gap: 7px;
      background: rgba(255,255,255,.03);
    }

    .setLabel {
      font-size: 12px;
      color: var(--muted);
    }

    .setButtons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .logMeta {
      font-size: 12px;
      color: var(--muted);
    }

    .logView {
      margin-top: 8px;
      border: 1px solid var(--line);
      border-radius: 10px;
      background: rgba(0, 0, 0, 0.35);
      max-height: 320px;
      overflow: auto;
      padding: 8px;
      font-family: "Cascadia Code", "Consolas", monospace;
      font-size: 11px;
      line-height: 1.45;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .hint {
      font-size: 12px;
      color: var(--muted);
    }

    #rowProgramHints {
      display: grid;
      gap: 8px;
      align-items: stretch;
    }

    #rowProgramHints > * {
      min-width: 0;
      flex: unset;
    }

    .suggestGrid {
      display: grid;
      gap: 8px;
      grid-template-columns: repeat(auto-fit, minmax(210px, 1fr));
    }

    .suggestBtn {
      border: 1px solid var(--line);
      background: rgba(0,0,0,.24);
      border-radius: 10px;
      color: var(--text);
      text-align: left;
      padding: 9px 10px;
      cursor: pointer;
      font-size: 12px;
    }

    .suggestBtn strong {
      display: block;
      font-size: 13px;
    }

    .suggestBtn span {
      display: block;
      margin-top: 2px;
      color: var(--muted);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    @media (max-width: 700px) {
      .topMenu { grid-template-columns: 1fr; }
      .search { min-width: 100%; }
      .tile { min-height: 92px; }
      #dlgOverlay {
        width: calc(100vw - 4px);
        max-height: 96vh;
      }
      .overlayShell {
        min-height: 92vh;
        max-height: 92vh;
      }

      #dlgSettings {
        width: calc(100vw - 6px);
        max-height: 96vh;
        padding-bottom: 78px;
      }

      #dlgSettings .btn,
      #dlgSettings .row input,
      #dlgSettings .row select {
        min-height: 48px;
        font-size: 14px;
      }

      #dlgSettings .setButtons {
        gap: 10px;
      }

      #dlgSettings .rowActions {
        display: none;
      }

      .settingsStickyBar {
        position: sticky;
        bottom: -12px;
        margin: 10px -12px -12px;
        padding: 10px 12px calc(10px + env(safe-area-inset-bottom));
        border-top: 1px solid var(--line);
        background: linear-gradient(180deg, rgba(4, 10, 18, 0.15), rgba(7, 14, 24, 0.94));
        display: grid;
        gap: 8px;
        grid-template-columns: repeat(4, minmax(0, 1fr));
        z-index: 20;
      }

      .settingsStickyBar .btn {
        min-height: 50px;
        font-size: 12px;
        padding: 8px 6px;
      }
    }

    @media (prefers-reduced-motion: reduce) {
      * { animation: none !important; transition: none !important; }
      .tile:hover { transform: none; }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="panel">
      <header>
        <div class="headTop">
          <div class="brand">
            <strong>StreamDeck Remote</strong>
            <span>Touch Launcher mit Profilen, Unterseiten und zentraler Programmlogik</span>
          </div>

          <div class="headActions">
            <div class="chip" title="API Status">
              <span class="dot" id="dotApi"></span>
              <span id="apiState">offline</span>
            </div>
            <div class="chip" title="WoW Prozess">
              <span class="dot" id="dotWow"></span>
              <span id="wowState">stopped</span>
            </div>

            <button class="btn primary" id="btnAdd" type="button">+ Tile</button>
            <button class="btn" id="btnShortcuts" type="button" title="Tastaturkuerzel anzeigen">Shortcuts</button>
            <button class="btn" id="btnSettings" type="button">Einstellungen</button>
          </div>
        </div>

        <div class="toolbar">
          <div class="topMenu">
            <div class="search">
              <span>Suche</span>
              <input id="q" type="search" placeholder="Filter: wow, logs, code..." autocomplete="off" />
              <button class="btn" id="clearQ" type="button">Clear</button>
            </div>
            <div class="quickProgram">
              <input id="quickProgramInput" type="search" placeholder="Programmname oder Pfad (z.B. obs, chrome, C:\\Tools\\app.exe)" autocomplete="off" />
              <button class="btn primary" id="quickProgramAdd" type="button">Programm als Tile</button>
            </div>
          </div>
          <div class="tabs" id="profileTabs"></div>
          <div class="tabs" id="pageTabs"></div>
        </div>
      </header>

      <main class="content">
        <section class="section" id="recentSection" hidden>
          <h2>Zuletzt benutzt <span style="font-size:12px; opacity:.75">Long-Press fuer Tile-Menue</span></h2>
          <div class="grid" id="recentGrid"></div>
        </section>

        <section class="section">
          <h2 id="sectionTitle">Tiles</h2>
          <div class="grid" id="grid"></div>
          <div class="empty" id="empty" hidden>Keine Tiles fuer diese Auswahl.</div>
        </section>
      </main>
    </div>
  </div>

  <div class="toast" id="toast" aria-live="polite"></div>

  <dialog id="dlgAdd">
    <div class="dlgTitle" id="addDialogTitle">Tile hinzufuegen</div>
    <div class="dlgHint" id="addDialogHint">Programm/Link/Ordner auswaehlen, speichern, fertig. Die App validiert Pfade automatisch.</div>

    <div class="row">
      <select id="addType">
        <option value="app">Programm (empfohlen)</option>
        <option value="url">Webseite (http/https)</option>
        <option value="folder">Ordner</option>
        <option value="protocol">Protokoll-Link (z.B. discord://)</option>
        <option value="action">Spezialaktion (advanced)</option>
      </select>
      <select id="addProfile"></select>
      <select id="addPage"></select>
    </div>

    <div class="row">
      <input id="addLabel" placeholder="Titel" maxlength="40" />
      <input id="addSubtitle" placeholder="Untertitel (optional)" maxlength="80" />
    </div>

    <div class="row" id="rowTarget">
      <input id="addTarget" placeholder="Ziel: URL oder Pfad" />
      <button class="btn" id="addBrowse" type="button">Browse</button>
    </div>
    <div class="row" id="rowProgramTools">
      <button class="btn" id="addFindProgram" type="button">Programm automatisch finden</button>
      <button class="btn" id="addTopPrograms" type="button">Installierte Apps anzeigen</button>
    </div>
    <div class="row" id="rowProgramHints" hidden>
      <div class="hint">Treffer aus deinem System (Pfad geprueft)</div>
      <div class="suggestGrid" id="addProgramHints"></div>
    </div>

    <div class="row" id="rowAction" hidden>
      <select id="addAction">
        <option value="terminal">terminal</option>
        <option value="powershell">powershell</option>
        <option value="browser">browser</option>
        <option value="discord">discord</option>
        <option value="streamingSoundboard">streamingSoundboard</option>
        <option value="wowNavigator">wowNavigator</option>
        <option value="curseforge">curseforge</option>
        <option value="curseforgeManager">curseforgeManager</option>
        <option value="performanceOverlay">performanceOverlay</option>
        <option value="wowStart">wowStart</option>
        <option value="openWorkspace">openWorkspace</option>
      </select>
    </div>

    <div class="row" id="rowArgs" hidden>
      <input id="addArgs" placeholder="Args (optional, getrennt mit Leerzeichen)" />
      <input id="addStartIn" placeholder="Startordner (optional)" />
    </div>

    <div class="row">
      <select id="addIconMode">
        <option value="auto">Icon: Auto (bei Programmen)</option>
        <option value="emoji">Icon: Emoji</option>
        <option value="image">Icon: Bilddatei</option>
      </select>
      <input id="addIconEmoji" placeholder="Emoji, z.B. 🚀" maxlength="8" />
      <input id="addIconFile" type="file" accept="image/*" />
    </div>
    <div class="row" id="rowIconPresets">
      <select id="addIconPreset"></select>
      <button class="btn" id="addIconPresetApply" type="button">Icon uebernehmen</button>
    </div>

    <div class="rowActions">
      <button class="btn" id="addCancel" type="button">Abbrechen</button>
      <button class="btn primary" id="addSave" type="button">Speichern</button>
    </div>
  </dialog>
  <dialog id="dlgTile">
    <div class="dlgTitle" id="tileMenuTitle">Tile</div>
    <div class="dlgHint">Built-ins koennen ausgeblendet werden, Custom Tiles koennen bearbeitet oder geloescht werden.</div>

    <div class="row">
      <button class="btn" id="tileFav" type="button">Favorit</button>
      <button class="btn" id="tileEdit" type="button">Bearbeiten</button>
      <button class="btn warn" id="tileHide" type="button">Ausblenden</button>
      <button class="btn danger" id="tileDelete" type="button">Loeschen</button>
    </div>

    <div class="rowActions">
      <button class="btn" id="tileClose" type="button">Schliessen</button>
    </div>
  </dialog>

  <dialog id="dlgSettings">
    <div class="dlgTitle">Einstellungen</div>
    <div class="dlgHint">Token und OpenAI-Key werden nur hier verwaltet. Unterseiten nutzen diese Werte automatisch.</div>

    <div class="row">
      <div class="inlineField">
        <input id="tokenInput" type="password" placeholder="Token" autocomplete="off" />
        <span class="fieldStatus info" id="tokenStatus">Token nicht geprueft</span>
      </div>
      <button class="btn primary" id="saveToken" type="button">Token speichern</button>
      <button class="btn" id="testToken" type="button">Token testen</button>
      <button class="btn" id="refreshAll" type="button">Neu laden</button>
    </div>

    <div class="setGroup">
      <div class="dlgTitle" style="font-size: 14px;">KI Assistant (WoW Navigator)</div>
      <div class="dlgHint">API-Key wird nach dem Speichern nicht angezeigt. Ein neuer Key wird vor dem Speichern verifiziert.</div>
      <div class="row">
        <div class="inlineField">
          <input id="aiModel" placeholder="Modell (z.B. gpt-4o-mini)" />
          <span class="fieldStatus info" id="aiModelStatus">Modell nicht geprueft</span>
        </div>
        <div class="inlineField">
          <input id="aiApiKey" type="password" placeholder="OpenAI API-Key (optional, sk-...)" autocomplete="off" />
          <span class="fieldStatus info" id="aiApiKeyStatus">API-Key optional</span>
        </div>
      </div>
      <div class="setButtons">
        <button class="btn primary" id="aiSave" type="button">KI speichern</button>
        <button class="btn warn" id="aiClear" type="button">API-Key entfernen</button>
      </div>
      <div class="logMeta" id="aiMeta">Kein KI-Status geladen.</div>
    </div>

    <div class="setGroup">
      <div class="dlgTitle" style="font-size: 14px;">Launcher Pfade</div>
      <div class="setButtons">
        <button class="btn" id="autoDetectAll" type="button">Alle automatisch erkennen</button>
      </div>
      <div id="launchersBox"></div>
    </div>

    <div class="setGroup">
      <div class="dlgTitle" style="font-size: 14px;">WoW Ordner + Prozess</div>
      <div id="wowBox"></div>
    </div>

    <div class="setGroup">
      <div class="dlgTitle" style="font-size: 14px;">Ausgeblendete Tiles</div>
      <div id="hiddenBox"></div>
    </div>

    <div class="setGroup">
      <div class="dlgTitle" style="font-size: 14px;">Server Logs</div>
      <div class="setButtons">
        <button class="btn" id="logsRefresh" type="button">Logs laden</button>
        <button class="btn" id="logsCopy" type="button">Logs kopieren</button>
      </div>
      <div class="row">
        <select id="logLines">
          <option value="100">100 Zeilen</option>
          <option value="200" selected>200 Zeilen</option>
          <option value="500">500 Zeilen</option>
          <option value="1000">1000 Zeilen</option>
        </select>
        <select id="logEnabled">
          <option value="true">Datei-Logging: aktiv</option>
          <option value="false">Datei-Logging: aus</option>
        </select>
        <select id="logLevel">
          <option value="ERROR">Level: ERROR</option>
          <option value="WARN">Level: WARN</option>
          <option value="INFO" selected>Level: INFO</option>
          <option value="DEBUG">Level: DEBUG</option>
        </select>
        <div class="inlineField">
          <input id="logMaxFiles" type="number" min="3" max="90" step="1" placeholder="max Dateien (3-90)" />
          <span class="fieldStatus info" id="logMaxFilesStatus">Log-Rotation nicht geprueft</span>
        </div>
      </div>
      <div class="row">
        <div class="inlineField">
          <input id="logDir" placeholder="Log-Ordner (optional, leer = Standard)" />
          <span class="fieldStatus info" id="logDirStatus">Log-Ordner Standard</span>
        </div>
        <button class="btn primary" id="logSave" type="button">Logging speichern</button>
      </div>
      <div class="logMeta" id="logMeta">Logs nicht geladen.</div>
      <pre class="logView" id="logView"></pre>
    </div>

    <div class="setGroup">
      <div class="dlgTitle" style="font-size: 14px;">Konfiguration (Backup / Import)</div>
      <div class="dlgHint">Exportiert bzw. importiert die komplette Konfiguration inkl. Profile/Tiles. Beim Import bleibt der aktuelle Token standardmaessig erhalten.</div>
      <div class="setButtons">
        <button class="btn" id="cfgExport" type="button">Config exportieren</button>
        <button class="btn warn" id="cfgImport" type="button">Config importieren</button>
      </div>
      <input id="cfgImportFile" type="file" accept=".json,application/json" hidden />
      <div class="logMeta" id="cfgMeta">Noch kein Import/Export ausgefuehrt.</div>
    </div>

    <div class="rowActions">
      <button class="btn" id="settingsClose" type="button">Schliessen</button>
    </div>
    <div class="settingsStickyBar" id="settingsStickyBar">
      <button class="btn primary" id="stickySaveToken" type="button">Token</button>
      <button class="btn primary" id="stickySaveAi" type="button">KI</button>
      <button class="btn primary" id="stickySaveLogging" type="button">Logging</button>
      <button class="btn" id="stickyCloseSettings" type="button">Schliessen</button>
    </div>
  </dialog>

  <dialog id="dlgOverlay">
    <div class="overlayShell">
      <div class="overlayHead">
        <div class="overlayTitleWrap">
          <strong id="overlayTitle">Unterseite</strong>
          <span id="overlayHint">Eingebettet im StreamDeck Overlay</span>
        </div>
        <div class="overlayActions">
          <button class="btn" id="overlayBack" type="button">Zurueck zur Hauptseite</button>
          <button class="btn" id="overlayClose" type="button">Schliessen</button>
        </div>
      </div>
      <div class="overlayFrameWrap">
        <iframe id="overlayFrame" title="StreamDeck Overlay Unterseite" loading="eager"></iframe>
      </div>
    </div>
  </dialog>

  <script>
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker
        .register("/sw.js", { updateViaCache: "none" })
        .then((reg) => reg.update().catch(() => {}))
        .catch(() => {});
    }

    const CLIENT_BUILD = "2026-02-24.1";
    const LS = {
      token: "sd_token",
      profile: "sd_profile",
      page: "sd_page",
      fav: "sd_fav",
      recent: "sd_recent",
      hidden: "sd_hidden"
    };
    const EMBEDDED_ACTION_PANELS = Object.freeze({
      streamingSoundboard: {
        path: "/Soundboard.html",
        title: "Streaming Soundboard",
        hint: "Per-App Mixer (Volume, Mute, Play/Pause) und Spotify-Bereich.",
        requiredFeature: "audioMixer"
      },
      wowNavigator: {
        path: "/WoWNavigator.html",
        title: "WoW Navigator",
        hint: "Quest-Hilfe, Wegpunkte und KI-Assistenz ohne Cheat-Mechanik.",
        requiredFeature: "wowNavigator"
      },
      performanceOverlay: {
        path: "/Performance.html",
        title: "Leistungs-Overlay",
        hint: "Livewerte fuer CPU, RAM, Netzwerk und Systemstatus.",
        requiredFeature: "systemMetrics"
      },
      curseforgeManager: {
        path: "/CurseForge.html",
        title: "CurseForge AddOn Manager",
        hint: "WoW AddOns direkt aktivieren/deaktivieren und CurseForge starten.",
        requiredFeature: "wowAddonsManager"
      }
    });

    function parseInitialRouteState() {
      try {
        const params = new URLSearchParams(window.location.search);
        return {
          profile: String(params.get("profile") || "").trim(),
          page: String(params.get("page") || "").trim(),
          panel: String(params.get("panel") || "").trim()
        };
      } catch {
        return { profile: "", page: "", panel: "" };
      }
    }

    const INITIAL_ROUTE = parseInitialRouteState();
    const ICON_PRESETS = Object.freeze([
      { id: "app-dev", emoji: "💻", label: "Editor / Entwicklung" },
      { id: "app-terminal", emoji: "🖥️", label: "Terminal / Konsole" },
      { id: "app-game", emoji: "🎮", label: "Gaming" },
      { id: "app-stream", emoji: "🎬", label: "Streaming / Video" },
      { id: "app-audio", emoji: "🎵", label: "Audio / Musik" },
      { id: "app-browser", emoji: "🌐", label: "Browser / Internet" },
      { id: "app-tools", emoji: "🛠️", label: "Tools / Utility" },
      { id: "app-note", emoji: "🧠", label: "Notizen / Wissen" },
      { id: "folder-main", emoji: "📁", label: "Ordner" },
      { id: "folder-archive", emoji: "🗂️", label: "Ablage / Archiv" },
      { id: "folder-media", emoji: "🖼️", label: "Medien" },
      { id: "folder-download", emoji: "📥", label: "Download" },
      { id: "url-site", emoji: "🌍", label: "Webseite" },
      { id: "url-docs", emoji: "📚", label: "Doku / Wiki" },
      { id: "url-shop", emoji: "🛒", label: "Shop" },
      { id: "url-news", emoji: "📰", label: "News" },
      { id: "protocol-chat", emoji: "💬", label: "Chat / Messenger" },
      { id: "protocol-mail", emoji: "✉️", label: "Mail" },
      { id: "protocol-call", emoji: "📞", label: "Call / Voice" },
      { id: "action-fast", emoji: "⚡", label: "Aktion schnell" },
      { id: "action-system", emoji: "⚙️", label: "System" },
      { id: "action-script", emoji: "🧰", label: "Skript / Automation" }
    ]);
    const ICON_PRESET_BY_TYPE = Object.freeze({
      app: ["app-dev", "app-terminal", "app-game", "app-stream", "app-tools"],
      folder: ["folder-main", "folder-archive", "folder-media", "folder-download"],
      url: ["url-site", "url-docs", "url-shop", "url-news"],
      protocol: ["protocol-chat", "protocol-mail", "protocol-call"],
      action: ["action-fast", "action-system", "action-script"]
    });

    function loadStoredArray(key, maxItems = 100) {
      try {
        const raw = localStorage.getItem(key);
        const parsed = raw ? JSON.parse(raw) : [];
        if (!Array.isArray(parsed)) return [];
        return parsed
          .filter((x) => typeof x === "string")
          .map((x) => x.trim())
          .filter(Boolean)
          .slice(0, maxItems);
      } catch {
        return [];
      }
    }

    const state = {
      token: localStorage.getItem(LS.token) || "",
      profile: INITIAL_ROUTE.profile || localStorage.getItem(LS.profile) || "",
      page: INITIAL_ROUTE.page || localStorage.getItem(LS.page) || "",
      favorites: new Set(loadStoredArray(LS.fav, 200)),
      recent: loadStoredArray(LS.recent, 50),
      hidden: new Set(loadStoredArray(LS.hidden, 200)),
      profiles: [],
      tiles: [],
      wowRunning: null,
      longPressTimer: null,
      longPressTileId: "",
      toastTimer: null,
      pollTimer: null,
      bootstrapTick: 0,
      addProgramSearchTimer: null,
      editingTileId: "",
      editingTileIconData: "",
      serverVersion: "",
      serverBuild: "",
      serverFeatures: {},
      legacyServerHintShown: false,
      pendingPanel: INITIAL_ROUTE.panel,
      overlayContext: null
    };

    const el = {
      profileTabs: document.getElementById("profileTabs"),
      pageTabs: document.getElementById("pageTabs"),
      q: document.getElementById("q"),
      clearQ: document.getElementById("clearQ"),
      sectionTitle: document.getElementById("sectionTitle"),
      grid: document.getElementById("grid"),
      empty: document.getElementById("empty"),
      recentSection: document.getElementById("recentSection"),
      recentGrid: document.getElementById("recentGrid"),

      apiState: document.getElementById("apiState"),
      dotApi: document.getElementById("dotApi"),
      wowState: document.getElementById("wowState"),
      dotWow: document.getElementById("dotWow"),

      btnAdd: document.getElementById("btnAdd"),
      btnShortcuts: document.getElementById("btnShortcuts"),
      btnSettings: document.getElementById("btnSettings"),
      quickProgramInput: document.getElementById("quickProgramInput"),
      quickProgramAdd: document.getElementById("quickProgramAdd"),

      toast: document.getElementById("toast"),

      dlgAdd: document.getElementById("dlgAdd"),
      addDialogTitle: document.getElementById("addDialogTitle"),
      addDialogHint: document.getElementById("addDialogHint"),
      addType: document.getElementById("addType"),
      addProfile: document.getElementById("addProfile"),
      addPage: document.getElementById("addPage"),
      addLabel: document.getElementById("addLabel"),
      addSubtitle: document.getElementById("addSubtitle"),
      addTarget: document.getElementById("addTarget"),
      addBrowse: document.getElementById("addBrowse"),
      rowTarget: document.getElementById("rowTarget"),
      rowProgramTools: document.getElementById("rowProgramTools"),
      addFindProgram: document.getElementById("addFindProgram"),
      addTopPrograms: document.getElementById("addTopPrograms"),
      rowProgramHints: document.getElementById("rowProgramHints"),
      addProgramHints: document.getElementById("addProgramHints"),
      rowAction: document.getElementById("rowAction"),
      addAction: document.getElementById("addAction"),
      rowArgs: document.getElementById("rowArgs"),
      addArgs: document.getElementById("addArgs"),
      addStartIn: document.getElementById("addStartIn"),
      addIconMode: document.getElementById("addIconMode"),
      addIconEmoji: document.getElementById("addIconEmoji"),
      addIconFile: document.getElementById("addIconFile"),
      rowIconPresets: document.getElementById("rowIconPresets"),
      addIconPreset: document.getElementById("addIconPreset"),
      addIconPresetApply: document.getElementById("addIconPresetApply"),
      addCancel: document.getElementById("addCancel"),
      addSave: document.getElementById("addSave"),

      dlgTile: document.getElementById("dlgTile"),
      tileMenuTitle: document.getElementById("tileMenuTitle"),
      tileFav: document.getElementById("tileFav"),
      tileEdit: document.getElementById("tileEdit"),
      tileHide: document.getElementById("tileHide"),
      tileDelete: document.getElementById("tileDelete"),
      tileClose: document.getElementById("tileClose"),

      dlgSettings: document.getElementById("dlgSettings"),
      tokenInput: document.getElementById("tokenInput"),
      tokenStatus: document.getElementById("tokenStatus"),
      saveToken: document.getElementById("saveToken"),
      testToken: document.getElementById("testToken"),
      refreshAll: document.getElementById("refreshAll"),
      aiModel: document.getElementById("aiModel"),
      aiModelStatus: document.getElementById("aiModelStatus"),
      aiApiKey: document.getElementById("aiApiKey"),
      aiApiKeyStatus: document.getElementById("aiApiKeyStatus"),
      aiSave: document.getElementById("aiSave"),
      aiClear: document.getElementById("aiClear"),
      aiMeta: document.getElementById("aiMeta"),
      autoDetectAll: document.getElementById("autoDetectAll"),
      launchersBox: document.getElementById("launchersBox"),
      wowBox: document.getElementById("wowBox"),
      hiddenBox: document.getElementById("hiddenBox"),
      logsRefresh: document.getElementById("logsRefresh"),
      logsCopy: document.getElementById("logsCopy"),
      logLines: document.getElementById("logLines"),
      logEnabled: document.getElementById("logEnabled"),
      logLevel: document.getElementById("logLevel"),
      logMaxFiles: document.getElementById("logMaxFiles"),
      logMaxFilesStatus: document.getElementById("logMaxFilesStatus"),
      logDir: document.getElementById("logDir"),
      logDirStatus: document.getElementById("logDirStatus"),
      logSave: document.getElementById("logSave"),
      logMeta: document.getElementById("logMeta"),
      logView: document.getElementById("logView"),
      cfgExport: document.getElementById("cfgExport"),
      cfgImport: document.getElementById("cfgImport"),
      cfgImportFile: document.getElementById("cfgImportFile"),
      cfgMeta: document.getElementById("cfgMeta"),
      settingsClose: document.getElementById("settingsClose"),
      settingsStickyBar: document.getElementById("settingsStickyBar"),
      stickySaveToken: document.getElementById("stickySaveToken"),
      stickySaveAi: document.getElementById("stickySaveAi"),
      stickySaveLogging: document.getElementById("stickySaveLogging"),
      stickyCloseSettings: document.getElementById("stickyCloseSettings"),

      dlgOverlay: document.getElementById("dlgOverlay"),
      overlayTitle: document.getElementById("overlayTitle"),
      overlayHint: document.getElementById("overlayHint"),
      overlayFrame: document.getElementById("overlayFrame"),
      overlayBack: document.getElementById("overlayBack"),
      overlayClose: document.getElementById("overlayClose")
    };

    function saveSet(key, setValue) {
      localStorage.setItem(key, JSON.stringify(Array.from(setValue)));
    }

    function showToast(message) {
      if (state.toastTimer) clearTimeout(state.toastTimer);
      el.toast.textContent = message;
      el.toast.className = "toast show";
      state.toastTimer = setTimeout(() => {
        el.toast.className = "toast";
      }, 2200);
    }

    function showLegacyServerHint(missingEndpoint) {
      if (state.legacyServerHintShown) return;
      state.legacyServerHintShown = true;
      showToast(`Server-Update noetig: ${missingEndpoint} fehlt. Bitte laufenden StreamDeck-Server neu starten.`);
    }

    function setApiState(text, statusClass) {
      el.apiState.textContent = text;
      el.dotApi.className = `dot ${statusClass || ""}`.trim();
    }

    function setWowState(text, statusClass) {
      el.wowState.textContent = text;
      el.dotWow.className = `dot ${statusClass || ""}`.trim();
    }

    function normalizeFieldStatus(result) {
      const item = result && typeof result === "object" ? result : {};
      const kindRaw = String(item.kind || item.level || "info").trim().toLowerCase();
      const kind = ["ok", "warn", "err", "info"].includes(kindRaw) ? kindRaw : "info";
      const text = String(item.text || "").trim() || "Status unbekannt";
      return { kind, text };
    }

    function setFieldStatus(chip, result) {
      if (!chip) return;
      const status = normalizeFieldStatus(result);
      chip.className = `fieldStatus ${status.kind}`;
      chip.textContent = status.text;
      chip.title = status.text;
    }

    function validateTokenField(rawValue) {
      const value = String(rawValue || "").trim();
      if (!value) return { kind: "err", text: "Token fehlt" };
      if (/[\s]/.test(value)) return { kind: "err", text: "Token darf keine Leerzeichen enthalten" };
      if (value.length < 12) return { kind: "err", text: "Token zu kurz (min. 12 Zeichen)" };
      return { kind: "ok", text: "Token-Format gueltig" };
    }

    function validateAiModelField(rawValue) {
      const value = String(rawValue || "").trim();
      if (!value) return { kind: "err", text: "Modell fehlt" };
      if (/[\r\n]/.test(value)) return { kind: "err", text: "Modell darf keinen Zeilenumbruch enthalten" };
      if (value.length > 80) return { kind: "err", text: "Modell zu lang (max. 80 Zeichen)" };
      return { kind: "ok", text: "Modell-Format gueltig" };
    }

    function validateAiApiKeyField(rawValue) {
      const value = String(rawValue || "").trim();
      if (!value) return { kind: "info", text: "Optional: leer = lokaler Fallback" };
      if (/[\r\n]/.test(value)) return { kind: "err", text: "API-Key darf keine Zeilenumbrueche enthalten" };
      if (/\s/.test(value)) return { kind: "err", text: "API-Key darf keine Leerzeichen enthalten" };
      if (value.length < 20) return { kind: "err", text: "API-Key wirkt zu kurz (min. 20 Zeichen)" };
      if (!/^sk-/i.test(value)) return { kind: "warn", text: "Ungewoehnliches Prefix, bitte pruefen" };
      return { kind: "ok", text: "API-Key-Format plausibel" };
    }

    function validatePathField(rawValue, options = {}) {
      const required = options.required === true;
      const emptyText = options.emptyText || (required ? "Pfad fehlt" : "Pfad optional");
      const value = String(rawValue || "").trim();
      if (!value) return { kind: required ? "warn" : "info", text: emptyText };
      if (/[\r\n]/.test(value)) return { kind: "err", text: "Pfad enthaelt ungueltige Zeilenumbrueche" };
      if (value.length > 2048) return { kind: "err", text: "Pfad zu lang" };
      if (looksLikePathInput(value) || /%[^%]+%/.test(value)) return { kind: "ok", text: "Pfad-Format plausibel" };
      return { kind: "warn", text: "Pfad-Format ungewoehnlich, bitte pruefen" };
    }

    function validateWowProcessField(rawValue) {
      const value = String(rawValue || "").trim();
      if (!value) return { kind: "err", text: "Prozessname fehlt" };
      if (/[\\/]/.test(value)) return { kind: "err", text: "Nur Dateiname erlaubt (kein Pfad)" };
      if (!/\.exe$/i.test(value)) return { kind: "warn", text: "Prozessname sollte auf .exe enden" };
      return { kind: "ok", text: "Prozessname plausibel" };
    }

    function validateLogMaxFilesField(rawValue) {
      const value = Number(String(rawValue || "").trim());
      if (!Number.isFinite(value)) return { kind: "err", text: "Bitte eine Zahl eingeben" };
      if (!Number.isInteger(value)) return { kind: "err", text: "Nur ganze Zahlen erlaubt" };
      if (value < 3 || value > 90) return { kind: "err", text: "Gueltiger Bereich: 3 bis 90" };
      return { kind: "ok", text: `Rotation: ${value} Dateien` };
    }

    function validateLogDirField(rawValue) {
      const value = String(rawValue || "").trim();
      if (!value) return { kind: "info", text: "Standard-Logordner wird verwendet" };
      if (/[\r\n]/.test(value)) return { kind: "err", text: "Log-Ordner enthaelt Zeilenumbrueche" };
      if (value.length > 2048) return { kind: "err", text: "Log-Ordner zu lang" };
      if (looksLikePathInput(value) || /%[^%]+%/.test(value)) return { kind: "ok", text: "Eigener Log-Ordner gesetzt" };
      return { kind: "warn", text: "Log-Ordner ungewoehnlich, bitte pruefen" };
    }

    function createInputStatusController(input, chip, validator, options = {}) {
      const getCurrent = () => String(input?.value || "").trim();
      const showChanged = options.showChanged !== false;
      const changedText = options.changedText || "Geaendert, noch nicht gespeichert";

      const run = (mode = "live") => {
        if (!input || !chip || typeof validator !== "function") return;
        const value = getCurrent();
        const base = String(input.dataset.statusBaseValue || "");
        const result = normalizeFieldStatus(validator(value));
        const isChanged = value !== base;
        if (result.kind === "err") {
          setFieldStatus(chip, result);
          return;
        }
        if (mode !== "saved" && showChanged && isChanged) {
          setFieldStatus(chip, { kind: "warn", text: changedText });
          return;
        }
        setFieldStatus(chip, result);
      };

      const setBase = (value) => {
        input.dataset.statusBaseValue = String(value ?? "").trim();
      };

      const markSaved = () => {
        setBase(getCurrent());
        run("saved");
      };

      setBase(options.baseValue !== undefined ? options.baseValue : getCurrent());
      input.addEventListener("input", () => run("live"));
      input.addEventListener("change", () => run("live"));
      run("saved");
      return {
        run,
        markSaved,
        setBase: (value) => {
          setBase(value);
          run("saved");
        }
      };
    }

    function createRowStatusController(row, input, validator, options = {}) {
      const chip = document.createElement("span");
      chip.className = "fieldStatus info";
      row.appendChild(chip);
      return createInputStatusController(input, chip, validator, options);
    }

    const settingsStatus = {
      token: null,
      aiModel: null,
      aiApiKey: null,
      logMaxFiles: null,
      logDir: null
    };

    function bindStaticSettingsStatusControllers() {
      if (!settingsStatus.token && el.tokenInput && el.tokenStatus) {
        settingsStatus.token = createInputStatusController(el.tokenInput, el.tokenStatus, validateTokenField);
      }
      if (!settingsStatus.aiModel && el.aiModel && el.aiModelStatus) {
        settingsStatus.aiModel = createInputStatusController(el.aiModel, el.aiModelStatus, validateAiModelField);
      }
      if (!settingsStatus.aiApiKey && el.aiApiKey && el.aiApiKeyStatus) {
        settingsStatus.aiApiKey = createInputStatusController(el.aiApiKey, el.aiApiKeyStatus, validateAiApiKeyField, {
          showChanged: false
        });
      }
      if (!settingsStatus.logMaxFiles && el.logMaxFiles && el.logMaxFilesStatus) {
        settingsStatus.logMaxFiles = createInputStatusController(el.logMaxFiles, el.logMaxFilesStatus, validateLogMaxFilesField);
      }
      if (!settingsStatus.logDir && el.logDir && el.logDirStatus) {
        settingsStatus.logDir = createInputStatusController(el.logDir, el.logDirStatus, validateLogDirField);
      }
    }

    function refreshStaticSettingsStatusControllers() {
      for (const key of Object.keys(settingsStatus)) {
        const ctl = settingsStatus[key];
        if (!ctl || typeof ctl.run !== "function") continue;
        ctl.run("live");
      }
    }

    function hasServerFeature(featureKey) {
      if (!featureKey) return true;
      if (!state.serverFeatures || typeof state.serverFeatures !== "object") return true;
      if (!Object.prototype.hasOwnProperty.call(state.serverFeatures, featureKey)) return true;
      return state.serverFeatures[featureKey] === true;
    }

    function overlayUrlFor(pathname) {
      const url = new URL(pathname, window.location.origin);
      url.searchParams.set("embed", "1");
      return `${url.pathname}${url.search}`;
    }

    function pageIdForMain(profileId) {
      const pages = pagesForProfile(profileId);
      return pages.some((p) => p.id === "main") ? "main" : (pages[0]?.id || "main");
    }

    function closeEmbeddedOverlay(options = {}) {
      const goMain = options.goMain === true;
      const context = state.overlayContext;
      if (el.dlgOverlay.open) el.dlgOverlay.close();

      if (goMain) {
        const profile = context?.profile && profileById(context.profile) ? context.profile : state.profile;
        state.profile = profile;
        state.page = pageIdForMain(profile);
        localStorage.setItem(LS.profile, state.profile);
        localStorage.setItem(LS.page, state.page);
        renderTiles();
      }
    }

    function openEmbeddedPanel(action, options = {}) {
      const descriptor = EMBEDDED_ACTION_PANELS[action];
      if (!descriptor) return false;
      if (!hasServerFeature(descriptor.requiredFeature)) {
        showLegacyServerHint(descriptor.requiredFeature);
        return false;
      }

      if (state.token) localStorage.setItem(LS.token, state.token);

      const fallbackProfile = options.profile || state.profile || "gaming";
      state.overlayContext = {
        action,
        profile: profileById(fallbackProfile) ? fallbackProfile : (state.profile || "gaming"),
        openedAt: Date.now()
      };

      el.overlayTitle.textContent = descriptor.title || "Unterseite";
      el.overlayHint.textContent = descriptor.hint || "Eingebettet im StreamDeck Overlay";
      el.overlayFrame.src = overlayUrlFor(descriptor.path);

      if (!el.dlgOverlay.open) el.dlgOverlay.showModal();
      return true;
    }

    async function api(path, opts = {}) {
      if (!state.token) throw new Error("Token fehlt");
      const method = opts.method || "GET";
      const headers = { "X-Token": state.token };
      if (opts.body) headers["Content-Type"] = "application/json";
      const response = await fetch(path, {
        method,
        headers,
        body: opts.body ? JSON.stringify(opts.body) : undefined
      });

      const data = await response.json().catch(() => null);
      const reqId = response.headers.get("x-request-id") || "";
      if (!response.ok) {
        const base = (data && data.error) ? data.error : `HTTP ${response.status}`;
        throw new Error(reqId ? `${base} (req ${reqId})` : base);
      }
      return data;
    }

    function formatExportFileName(prefix = "streamdeck_remote-config") {
      const now = new Date();
      const pad = (n) => String(n).padStart(2, "0");
      const stamp = `${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(now.getDate())}_${pad(now.getHours())}-${pad(now.getMinutes())}-${pad(now.getSeconds())}`;
      return `${prefix}-${stamp}.json`;
    }

    function downloadJsonFile(fileName, value) {
      const blob = new Blob([JSON.stringify(value, null, 2)], { type: "application/json;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      try {
        const a = document.createElement("a");
        a.href = url;
        a.download = fileName;
        document.body.appendChild(a);
        a.click();
        a.remove();
      } finally {
        setTimeout(() => URL.revokeObjectURL(url), 2500);
      }
    }

    function isEditableElement(node) {
      if (!(node instanceof HTMLElement)) return false;
      const tag = node.tagName;
      return node.isContentEditable || tag === "INPUT" || tag === "TEXTAREA" || tag === "SELECT";
    }

    function profileById(id) {
      return state.profiles.find((p) => p.id === id) || null;
    }

    function pagesForProfile(profileId) {
      const p = profileById(profileId);
      if (!p || !Array.isArray(p.pages) || !p.pages.length) return [{ id: "main", label: "Main" }];
      return p.pages;
    }

    function parseArgs(text) {
      const raw = String(text || "").trim();
      if (!raw) return [];
      const out = [];
      const re = /"([^"]*)"|'([^']*)'|(\S+)/g;
      let m = null;
      while ((m = re.exec(raw)) !== null) {
        out.push(m[1] || m[2] || m[3] || "");
      }
      return out.filter(Boolean);
    }

    function formatArgs(args) {
      const list = Array.isArray(args) ? args : [];
      return list.map((x) => (/\s/.test(String(x)) ? `"${String(x)}"` : String(x))).join(" ").trim();
    }

    function escapeCssValue(value) {
      const raw = String(value || "");
      if (window.CSS && typeof window.CSS.escape === "function") return window.CSS.escape(raw);
      return raw.replace(/["\\]/g, "\\$&");
    }

    function preferredProfileId() {
      if (state.profile && state.profile !== "fav") return state.profile;
      return state.profiles.find((p) => p.id !== "fav")?.id || state.profiles[0]?.id || "work";
    }

    function preferredPageId(profileId) {
      const pages = pagesForProfile(profileId);
      if (state.page && pages.some((p) => p.id === state.page)) return state.page;
      return pages[0]?.id || "main";
    }

    function inferProgramLabel(rawPath) {
      const value = String(rawPath || "").trim();
      if (!value) return "";
      const base = value.split(/[\\/]/).pop() || value;
      return base.replace(/\.[^/.]+$/, "").replace(/[-_]+/g, " ").trim();
    }

    function iconPresetById(id) {
      const key = String(id || "").trim();
      return ICON_PRESETS.find((x) => x.id === key) || null;
    }

    function renderIconPresetMenu(tileType) {
      const type = String(tileType || "").trim().toLowerCase();
      const recommendedIds = ICON_PRESET_BY_TYPE[type] || [];
      const recommendedSet = new Set(recommendedIds);
      el.addIconPreset.textContent = "";

      const placeholder = document.createElement("option");
      placeholder.value = "";
      placeholder.textContent = "Icon-Bibliothek: Bitte waehlen...";
      el.addIconPreset.appendChild(placeholder);

      if (recommendedIds.length) {
        const recommendedGroup = document.createElement("optgroup");
        recommendedGroup.label = "Empfohlen";
        for (const presetId of recommendedIds) {
          const preset = iconPresetById(presetId);
          if (!preset) continue;
          const opt = document.createElement("option");
          opt.value = preset.emoji;
          opt.textContent = `${preset.emoji} ${preset.label}`;
          recommendedGroup.appendChild(opt);
        }
        if (recommendedGroup.children.length) el.addIconPreset.appendChild(recommendedGroup);
      }

      const allGroup = document.createElement("optgroup");
      allGroup.label = "Alle Icons";
      for (const preset of ICON_PRESETS) {
        if (recommendedSet.has(preset.id)) continue;
        const opt = document.createElement("option");
        opt.value = preset.emoji;
        opt.textContent = `${preset.emoji} ${preset.label}`;
        allGroup.appendChild(opt);
      }
      if (allGroup.children.length) el.addIconPreset.appendChild(allGroup);
    }

    function applyIconPreset(emoji) {
      const icon = String(emoji || "").trim();
      if (!icon) throw new Error("Bitte zuerst ein Icon aus der Bibliothek waehlen");
      el.addIconMode.value = "emoji";
      el.addIconEmoji.value = icon;
      updateAddFormVisibility();
    }

    function tileTypeLabel(type) {
      const key = String(type || "").toLowerCase();
      if (key === "app") return "APP";
      if (key === "folder") return "ORDNER";
      if (key === "url") return "WEB";
      if (key === "protocol") return "PROTOKOLL";
      if (key === "action") return "AKTION";
      return key ? key.toUpperCase() : "TILE";
    }

    function buildTileButtonNode(tile) {
      const btn = document.createElement("button");
      btn.className = "tile";
      btn.type = "button";
      btn.dataset.id = tile.id;
      btn.dataset.type = String(tile.type || "").toLowerCase();
      btn.setAttribute("aria-label", tile.subtitle ? `${tile.label}, ${tile.subtitle}` : tile.label);

      btn.appendChild(tileIconNode(tile));

      const meta = document.createElement("div");
      meta.className = "meta";
      const top = document.createElement("div");
      top.className = "metaTop";

      const title = document.createElement("strong");
      title.textContent = tile.label;
      top.appendChild(title);

      const type = document.createElement("span");
      type.className = "typePill";
      type.textContent = tileTypeLabel(tile.type);
      type.title = `Tile-Typ: ${tile.type || "unknown"}`;
      top.appendChild(type);

      const sub = document.createElement("span");
      sub.textContent = tile.subtitle || tile.type;

      meta.appendChild(top);
      meta.appendChild(sub);
      btn.appendChild(meta);
      return btn;
    }

    function unquoteInput(value) {
      const text = String(value || "").trim();
      if ((text.startsWith("\"") && text.endsWith("\"")) || (text.startsWith("'") && text.endsWith("'"))) {
        return text.slice(1, -1).trim();
      }
      return text;
    }

    function looksLikePathInput(value) {
      const text = unquoteInput(value);
      return /^[a-z]:[\\/]/i.test(text) || text.includes("\\") || text.includes("/") || text.startsWith(".\\");
    }

    function splitAppTargetInput(rawInput) {
      const raw = String(rawInput || "").trim();
      if (!raw) return { target: "", inlineArgs: [] };

      const pathWithArgs = raw.match(/^(.+\.(?:exe|lnk|bat|cmd|com))(?:\s+(.+))?$/i);
      if (pathWithArgs) {
        return {
          target: unquoteInput(pathWithArgs[1]),
          inlineArgs: parseArgs(pathWithArgs[2] || "")
        };
      }

      const tokens = parseArgs(raw);
      if (tokens.length > 1 && looksLikePathInput(tokens[0])) {
        return {
          target: unquoteInput(tokens[0]),
          inlineArgs: tokens.slice(1)
        };
      }

      return { target: unquoteInput(raw), inlineArgs: [] };
    }

    function isHttp404Error(error) {
      return /HTTP 404/i.test(String(error?.message || error || ""));
    }

    async function fetchPrograms(query = "", limit = 16) {
      const q = encodeURIComponent(String(query || "").trim());
      const l = Math.max(1, Math.min(50, Number(limit) || 16));
      const data = await api(`/api/programs?q=${q}&limit=${l}`);
      return Array.isArray(data.programs) ? data.programs : [];
    }

    async function resolveProgramInput(input, options = {}) {
      const allowDirectPathFallback = Boolean(options.allowDirectPathFallback);
      try {
        const data = await api("/api/programs/resolve", { method: "POST", body: { input } });
        if (!data || !data.path) throw new Error("Programm nicht gefunden");
        return String(data.path);
      } catch (error) {
        if (allowDirectPathFallback && looksLikePathInput(input)) {
          return unquoteInput(input);
        }
        if (isHttp404Error(error)) {
          showLegacyServerHint("/api/programs/resolve");
          throw new Error("Programmsuche-Endpunkt fehlt auf dem laufenden Server. Bitte Server neu starten.");
        }
        throw error;
      }
    }

    async function fetchTileDetails(id) {
      if (!id) throw new Error("Tile-ID fehlt");
      if (!state.serverFeatures || state.serverFeatures.tileDetails !== true) {
        showLegacyServerHint("/api/tiles/:id");
        throw new Error("Tile-Details-Endpunkt fehlt auf dem laufenden Server. Bitte Server neu starten.");
      }
      try {
        const data = await api(`/api/tiles/${encodeURIComponent(id)}`);
        if (!data || !data.tile) throw new Error("Tile konnte nicht geladen werden");
        return data.tile;
      } catch (error) {
        if (isHttp404Error(error)) {
          showLegacyServerHint("/api/tiles/:id");
          throw new Error("Tile-Details-Endpunkt fehlt auf dem laufenden Server. Bitte Server neu starten.");
        }
        throw error;
      }
    }

    function useProgramSuggestion(program) {
      if (!program || !program.path) return;
      el.addTarget.value = program.path;
      if (!el.addLabel.value.trim()) el.addLabel.value = program.label || inferProgramLabel(program.path);
      if (!el.addSubtitle.value.trim()) {
        const sourceLabel = program.source ? `Auto: ${program.source}` : "Auto gefunden";
        el.addSubtitle.value = sourceLabel;
      }
      if (el.addIconMode.value === "emoji") {
        el.addIconMode.value = "auto";
        updateAddFormVisibility();
      }
      showToast(`Programm gewaehlt: ${program.label || inferProgramLabel(program.path)}`);
    }

    function renderProgramSuggestions(programs = []) {
      el.addProgramHints.textContent = "";
      if (!Array.isArray(programs) || !programs.length) {
        el.rowProgramHints.hidden = true;
        return;
      }
      el.rowProgramHints.hidden = false;
      for (const program of programs) {
        const btn = document.createElement("button");
        btn.className = "suggestBtn";
        btn.type = "button";
        const title = document.createElement("strong");
        title.textContent = program.label || inferProgramLabel(program.path);
        const sub = document.createElement("span");
        sub.textContent = program.path || "";
        btn.appendChild(title);
        btn.appendChild(sub);
        btn.addEventListener("click", () => useProgramSuggestion(program));
        el.addProgramHints.appendChild(btn);
      }
    }

    async function quickAddProgram(input) {
      if (!state.token) throw new Error("Bitte zuerst Token setzen");
      const query = String(input || "").trim();
      if (!query) throw new Error("Bitte Programmname oder Pfad eingeben");
      const splitInput = splitAppTargetInput(query);
      const targetInput = splitInput.target || query;

      let resolvedPath = "";
      try {
        resolvedPath = await resolveProgramInput(targetInput, { allowDirectPathFallback: true });
      } catch (error) {
        if (looksLikePathInput(targetInput)) {
          resolvedPath = unquoteInput(targetInput);
        } else {
          throw error;
        }
      }
      const profile = preferredProfileId();
      const page = preferredPageId(profile);
      const label = inferProgramLabel(resolvedPath);

      const tile = {
        profile,
        page,
        type: "app",
        label: label || "Programm",
        subtitle: "Auto hinzugefuegt",
        target: resolvedPath,
        iconMode: "auto"
      };
      if (splitInput.inlineArgs.length) tile.args = splitInput.inlineArgs;

      await api("/api/tiles/upsert", { method: "POST", body: { tile } });
      await loadBootstrap();
      showToast(`Programm-Tile erstellt: ${tile.label}`);
    }

    function renderSettingsNeedToken() {
      const msg = "Token fehlt. Bitte Token speichern, dann werden Einstellungen und Logs geladen.";
      el.launchersBox.textContent = "";
      el.wowBox.textContent = "";
      el.hiddenBox.textContent = "";

      const node1 = document.createElement("div");
      node1.className = "setLabel";
      node1.textContent = msg;
      const node2 = document.createElement("div");
      node2.className = "setLabel";
      node2.textContent = msg;
      const node3 = document.createElement("div");
      node3.className = "setLabel";
      node3.textContent = msg;
      el.launchersBox.appendChild(node1);
      el.wowBox.appendChild(node2);
      el.hiddenBox.appendChild(node3);

      el.logMeta.textContent = msg;
      el.logView.textContent = "";
      el.cfgMeta.textContent = msg;
      el.aiMeta.textContent = msg;
      el.aiModel.value = "gpt-4o-mini";
      el.aiApiKey.value = "";
      el.logEnabled.value = "true";
      el.logLevel.value = "INFO";
      el.logMaxFiles.value = "14";
      el.logDir.value = "";
      el.aiModel.disabled = true;
      el.aiApiKey.disabled = true;
      el.aiSave.disabled = true;
      el.aiClear.disabled = true;
      el.logsRefresh.disabled = true;
      el.logsCopy.disabled = true;
      el.logSave.disabled = true;
      el.logEnabled.disabled = true;
      el.logLevel.disabled = true;
      el.logMaxFiles.disabled = true;
      el.logDir.disabled = true;
      el.logLines.disabled = true;
      el.cfgExport.disabled = true;
      el.cfgImport.disabled = true;
      el.cfgImportFile.disabled = true;
      el.stickySaveToken.disabled = false;
      el.stickySaveAi.disabled = true;
      el.stickySaveLogging.disabled = true;
      setFieldStatus(el.tokenStatus, { kind: "err", text: "Token fehlt" });
      setFieldStatus(el.aiModelStatus, { kind: "warn", text: "Token noetig fuer KI-Settings" });
      setFieldStatus(el.aiApiKeyStatus, { kind: "warn", text: "Token noetig fuer KI-Settings" });
      setFieldStatus(el.logMaxFilesStatus, { kind: "warn", text: "Token noetig fuer Logging-Settings" });
      setFieldStatus(el.logDirStatus, { kind: "warn", text: "Token noetig fuer Logging-Settings" });
    }

    function setAiUi(ai) {
      const status = ai && typeof ai === "object" ? ai : {};
      const hasApiKey = status.hasApiKey === true;
      const source = String(status.source || "none");
      const keyManagedByEnv = status.keyManagedByEnv === true;
      const model = String(status.model || "gpt-4o-mini").trim() || "gpt-4o-mini";

      el.aiModel.value = model;
      el.aiApiKey.value = "";
      el.aiModel.disabled = false;
      el.aiApiKey.disabled = keyManagedByEnv;
      el.aiSave.disabled = false;
      el.aiClear.disabled = keyManagedByEnv || !hasApiKey;
      el.stickySaveAi.disabled = false;
      if (settingsStatus.aiModel) settingsStatus.aiModel.setBase(model);
      if (settingsStatus.aiApiKey) settingsStatus.aiApiKey.setBase("");

      const provider = String(status.provider || "openai");
      const keyText = hasApiKey
        ? (keyManagedByEnv ? "API-Key aktiv (Quelle: Umgebungsvariable)." : "API-Key gespeichert (aus Sicherheitsgruenden ausgeblendet).")
        : "Kein API-Key gespeichert (lokaler Fallback aktiv).";
      const modelHint = keyManagedByEnv
        ? "API-Key wird extern gesetzt und kann hier nicht geaendert werden."
        : "Du kannst den Key hier aktualisieren oder entfernen.";
      el.aiMeta.textContent = `Provider: ${provider} | Modell: ${model} | ${keyText} ${modelHint}`;
      if (source === "env") {
        el.aiMeta.textContent += " Quelle: env.";
      } else if (source === "config") {
        el.aiMeta.textContent += " Quelle: config.";
      } else {
        el.aiMeta.textContent += " Quelle: none.";
      }
      if (hasApiKey) {
        setFieldStatus(el.aiApiKeyStatus, {
          kind: keyManagedByEnv ? "info" : "ok",
          text: keyManagedByEnv
            ? "API-Key via env aktiv (in UI gesperrt)"
            : "API-Key gespeichert (ausgeblendet)"
        });
      } else {
        setFieldStatus(el.aiApiKeyStatus, { kind: "info", text: "Kein API-Key gespeichert (Fallback aktiv)" });
      }
      if (settingsStatus.aiModel) settingsStatus.aiModel.run("saved");
    }

    function setLoggingUi(logging) {
      const enabled = logging?.enabled !== false;
      el.logEnabled.value = enabled ? "true" : "false";
      el.logLevel.value = String(logging?.effectiveLevel || logging?.level || "INFO").toUpperCase();
      el.logMaxFiles.value = String(logging?.maxFiles || 14);
      el.logDir.value = String(logging?.dir || "");
      if (settingsStatus.logMaxFiles) settingsStatus.logMaxFiles.setBase(el.logMaxFiles.value);
      if (settingsStatus.logDir) settingsStatus.logDir.setBase(el.logDir.value);
      el.logsRefresh.disabled = false;
      el.logsCopy.disabled = false;
      el.logSave.disabled = false;
      el.logEnabled.disabled = false;
      el.logLevel.disabled = false;
      el.logMaxFiles.disabled = false;
      el.logDir.disabled = false;
      el.logLines.disabled = false;
      el.cfgExport.disabled = false;
      el.cfgImport.disabled = false;
      el.cfgImportFile.disabled = false;
      el.stickySaveLogging.disabled = false;
    }

    async function loadRecentLogs() {
      const lines = Math.max(10, Math.min(2000, Number(el.logLines.value) || 200));
      let data = null;
      try {
        data = await api(`/api/logs/recent?lines=${lines}`);
      } catch (error) {
        if (isHttp404Error(error)) {
          showLegacyServerHint("/api/logs/recent");
          throw new Error("Log-Endpunkt fehlt auf dem laufenden Server. Bitte Server neu starten.");
        }
        throw error;
      }
      const logLines = Array.isArray(data.lines) ? data.lines : [];
      el.logView.textContent = logLines.join("\n");
      el.logMeta.textContent = `Zeilen: ${logLines.length} | Ordner: ${data.logDir || "-"} | Logging: ${data.loggingEnabled ? "aktiv" : "aus"} | Level: ${data.loggingLevel || "-"}`;
    }

    function tileIconNode(tile) {
      const wrap = document.createElement("div");
      wrap.className = "iconWrap";

      if (tile.iconData) {
        const img = document.createElement("img");
        img.src = tile.iconData;
        img.alt = "";
        wrap.appendChild(img);
        return wrap;
      }

      wrap.textContent = tile.icon || "■";
      return wrap;
    }

    function applySearchFilter(tile, q) {
      if (!q) return true;
      const needle = q.toLowerCase();
      return [tile.label, tile.subtitle, tile.type]
        .filter(Boolean)
        .some((v) => String(v).toLowerCase().includes(needle));
    }

    function allVisibleTiles() {
      return state.tiles.filter((t) => !state.hidden.has(t.id));
    }

    function currentTiles() {
      const q = el.q.value.trim();
      const tiles = allVisibleTiles().filter((t) => applySearchFilter(t, q));
      if (state.profile === "fav") {
        return tiles.filter((t) => state.favorites.has(t.id));
      }
      return tiles.filter((t) => t.profile === state.profile && (t.page || "main") === state.page);
    }

    function renderProfileTabs() {
      el.profileTabs.textContent = "";
      for (const p of state.profiles) {
        const btn = document.createElement("button");
        btn.className = "tab";
        btn.type = "button";
        btn.dataset.profile = p.id;
        btn.setAttribute("aria-selected", String(p.id === state.profile));
        btn.textContent = p.label;
        el.profileTabs.appendChild(btn);
      }
    }

    function renderPageTabs() {
      el.pageTabs.textContent = "";
      const pages = pagesForProfile(state.profile);
      for (const page of pages) {
        const btn = document.createElement("button");
        btn.className = "tab";
        btn.type = "button";
        btn.dataset.page = page.id;
        btn.setAttribute("aria-selected", String(page.id === state.page));
        btn.textContent = page.label;
        el.pageTabs.appendChild(btn);
      }
    }
    function renderTiles() {
      renderProfileTabs();
      renderPageTabs();

      const profileLabel = profileById(state.profile)?.label || "Tiles";
      const pageLabel = pagesForProfile(state.profile).find((p) => p.id === state.page)?.label || "Main";
      el.sectionTitle.textContent = `${profileLabel} / ${pageLabel}`;

      const tiles = currentTiles();
      el.grid.textContent = "";

      for (const tile of tiles) {
        const btn = buildTileButtonNode(tile);

        if (state.favorites.has(tile.id)) {
          const fav = document.createElement("div");
          fav.className = "fav";
          fav.textContent = "Fav";
          btn.appendChild(fav);
        }

        el.grid.appendChild(btn);
      }

      el.empty.hidden = tiles.length > 0;

      el.recentGrid.textContent = "";
      const map = new Map(allVisibleTiles().map((t) => [t.id, t]));
      const recentTiles = state.recent.map((id) => map.get(id)).filter(Boolean).slice(0, 6);
      if (el.q.value.trim() || !recentTiles.length) {
        el.recentSection.hidden = true;
      } else {
        el.recentSection.hidden = false;
        for (const tile of recentTiles) {
          const node = buildTileButtonNode(tile);
          el.recentGrid.appendChild(node);
        }
      }
    }

    async function loadBootstrap() {
      const data = await api("/api/bootstrap");
      state.profiles = Array.isArray(data.profiles) ? data.profiles : [];
      state.tiles = Array.isArray(data.tiles) ? data.tiles : [];
      state.wowRunning = Boolean(data.wowRunning);
      state.serverVersion = String(data.serverVersion || state.serverVersion || "");
      state.serverBuild = String(data.serverBuild || state.serverBuild || "");
      state.serverFeatures = data.features && typeof data.features === "object" ? data.features : state.serverFeatures;

      if (!state.profile || !profileById(state.profile)) {
        state.profile = state.profiles[0]?.id || "work";
      }

      const pages = pagesForProfile(state.profile);
      if (!state.page || !pages.some((p) => p.id === state.page)) {
        state.page = pages[0]?.id || "main";
      }

      localStorage.setItem(LS.profile, state.profile);
      localStorage.setItem(LS.page, state.page);
      renderTiles();
    }

    async function pollStatus() {
      try {
        const health = await api("/api/health");
        state.serverVersion = String(health?.version || state.serverVersion || "");
        state.serverBuild = String(health?.build || state.serverBuild || "");
        state.serverFeatures = health?.features && typeof health.features === "object"
          ? health.features
          : state.serverFeatures;

        const suffix = state.serverVersion ? ` v${state.serverVersion}` : "";
        setApiState(`online${suffix}`, "ok");
        if (!health?.features || health.features.logsRecent !== true || health.features.programResolve !== true) {
          showLegacyServerHint("neue API-Features");
        }
      } catch (error) {
        setApiState(state.token ? "offline" : "token?", state.token ? "err" : "");
      }

      try {
        const st = await api("/api/status");
        state.wowRunning = Boolean(st.wowRunning);
        setWowState(state.wowRunning ? "running" : "stopped", state.wowRunning ? "ok" : "");
      } catch {
        state.wowRunning = null;
        setWowState("unknown", "err");
      }
    }

    function pushRecent(id) {
      state.recent = [id, ...state.recent.filter((x) => x !== id)].slice(0, 12);
      localStorage.setItem(LS.recent, JSON.stringify(state.recent));
    }

    async function runTile(id) {
      const tile = state.tiles.find((x) => x.id === id);
      if (!tile) return;

      const target = document.querySelector(`button.tile[data-id="${escapeCssValue(id)}"]`);
      if (target) target.disabled = true;

      try {
        if (tile.type === "action" && tile.action) {
          const opened = openEmbeddedPanel(tile.action, { profile: tile.profile || state.profile });
          if (opened) {
            pushRecent(id);
            setApiState("ok", "ok");
            showToast(`Overlay geoeffnet: ${tile.label}`);
            return;
          }
        }

        await api("/api/run", { method: "POST", body: { tileId: id } });
        pushRecent(id);
        setApiState("ok", "ok");
        showToast(`Ausgefuehrt: ${tile.label}`);
      } catch (error) {
        setApiState("fehler", "err");
        showToast(`Fehler: ${error.message || String(error)}`);
      } finally {
        if (target) target.disabled = false;
        renderTiles();
      }
    }

    function openTileMenu(tile) {
      el.tileMenuTitle.textContent = tile.label;
      el.tileFav.textContent = state.favorites.has(tile.id) ? "Favorit entfernen" : "Als Favorit";
      el.tileEdit.style.display = tile.builtin ? "none" : "";
      el.tileDelete.style.display = tile.builtin ? "none" : "";
      el.tileHide.style.display = "";
      if (!el.dlgTile.open) el.dlgTile.showModal();

      el.tileFav.onclick = () => {
        if (state.favorites.has(tile.id)) state.favorites.delete(tile.id);
        else state.favorites.add(tile.id);
        saveSet(LS.fav, state.favorites);
        renderTiles();
        el.dlgTile.close();
      };

      el.tileHide.onclick = () => {
        state.hidden.add(tile.id);
        saveSet(LS.hidden, state.hidden);
        renderTiles();
        el.dlgTile.close();
      };

      el.tileEdit.onclick = async () => {
        if (tile.builtin) return;
        el.dlgTile.close();
        try {
          await openAddDialog(tile);
        } catch (error) {
          showToast(`Bearbeiten fehlgeschlagen: ${error.message || String(error)}`);
        }
      };

      el.tileDelete.onclick = async () => {
        if (tile.builtin) return;
        try {
          await api("/api/tiles/delete", { method: "POST", body: { id: tile.id } });
          state.favorites.delete(tile.id);
          state.hidden.delete(tile.id);
          saveSet(LS.fav, state.favorites);
          saveSet(LS.hidden, state.hidden);
          await loadBootstrap();
          showToast("Tile geloescht");
        } catch (error) {
          showToast(`Loeschen fehlgeschlagen: ${error.message || String(error)}`);
        } finally {
          el.dlgTile.close();
        }
      };

      el.tileClose.onclick = () => el.dlgTile.close();
    }

    function openTileMenuById(tileId) {
      const tile = state.tiles.find((x) => x.id === tileId);
      if (tile) openTileMenu(tile);
    }

    function fillProfileSelect(selectEl, selectedId) {
      selectEl.textContent = "";
      for (const p of state.profiles) {
        if (p.id === "fav") continue;
        const opt = document.createElement("option");
        opt.value = p.id;
        opt.textContent = p.label;
        selectEl.appendChild(opt);
      }
      if (selectedId && Array.from(selectEl.options).some((o) => o.value === selectedId)) {
        selectEl.value = selectedId;
      }
    }

    function fillPageSelect(profileId, pageSelect, selectedId = "") {
      pageSelect.textContent = "";
      const pages = pagesForProfile(profileId);
      for (const page of pages) {
        const opt = document.createElement("option");
        opt.value = page.id;
        opt.textContent = page.label;
        pageSelect.appendChild(opt);
      }
      if (selectedId && Array.from(pageSelect.options).some((o) => o.value === selectedId)) {
        pageSelect.value = selectedId;
      }
    }

    function updateAddFormVisibility() {
      const type = el.addType.value;
      el.rowAction.hidden = type !== "action";
      el.rowTarget.hidden = type === "action";
      el.rowArgs.hidden = type !== "app";
      el.rowProgramTools.hidden = type !== "app";
      if (type !== "app") el.rowProgramHints.hidden = true;

      if (type === "app") el.addTarget.placeholder = "Programmname oder Pfad (z.B. obs, chrome, C:\\Apps\\tool.exe)";
      else if (type === "url") el.addTarget.placeholder = "https://...";
      else if (type === "folder") el.addTarget.placeholder = "Ordnerpfad";
      else if (type === "protocol") el.addTarget.placeholder = "protocol://...";
      else el.addTarget.placeholder = "Ziel";

      const iconMode = el.addIconMode.value;
      el.addIconEmoji.style.display = iconMode === "emoji" ? "" : "none";
      el.addIconFile.style.display = iconMode === "image" ? "" : "none";

      const browseKind = type === "folder" ? "folder" : "file";
      el.addBrowse.dataset.kind = browseKind;
      el.addBrowse.style.display = (type === "app" || type === "folder") ? "" : "none";
    }

    async function readImageDataUrl(file) {
      if (!file) return "";
      if (file.size > 2 * 1024 * 1024) {
        throw new Error("Bild zu gross (max 2 MB)");
      }
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(String(reader.result || ""));
        reader.onerror = () => reject(new Error("Bild konnte nicht gelesen werden"));
        reader.readAsDataURL(file);
      });
    }

    function setAddDialogMode(editing) {
      if (editing) {
        el.addDialogTitle.textContent = "Tile bearbeiten";
        el.addDialogHint.textContent = "Du aktualisierst ein bestehendes Custom Tile. Built-in Tiles bleiben unveraendert.";
        el.addSave.textContent = "Aenderungen speichern";
      } else {
        el.addDialogTitle.textContent = "Tile hinzufuegen";
        el.addDialogHint.textContent = "Programm/Link/Ordner auswaehlen, speichern, fertig. Die App validiert Pfade automatisch.";
        el.addSave.textContent = "Speichern";
      }
    }

    function resetAddDialogForm(profileId, pageId) {
      const profile = profileId || preferredProfileId();
      fillProfileSelect(el.addProfile, profile);
      fillPageSelect(el.addProfile.value || profile, el.addPage, pageId || state.page || "main");

      el.addType.value = "app";
      el.addLabel.value = "";
      el.addSubtitle.value = "";
      el.addTarget.value = "";
      el.addAction.value = "terminal";
      el.addArgs.value = "";
      el.addStartIn.value = "";
      el.addIconMode.value = "auto";
      el.addIconEmoji.value = "";
      el.addIconFile.value = "";
      renderIconPresetMenu("app");
      el.addIconPreset.value = "";
      el.addProgramHints.textContent = "";
      el.rowProgramHints.hidden = true;
      state.editingTileId = "";
      state.editingTileIconData = "";
      setAddDialogMode(false);
    }

    async function openAddDialog(editTile = null) {
      const profile = preferredProfileId();
      resetAddDialogForm(profile, state.page || "main");

      if (editTile && editTile.id) {
        const details = await fetchTileDetails(editTile.id);
        if (details.builtin) throw new Error("Built-in Tiles koennen nicht bearbeitet werden");

        state.editingTileId = details.id;
        state.editingTileIconData = details.iconMode === "image" ? String(details.iconData || "") : "";
        setAddDialogMode(true);

        fillProfileSelect(el.addProfile, details.profile || profile);
        fillPageSelect(el.addProfile.value || details.profile || profile, el.addPage, details.page || "main");

        el.addType.value = details.type || "app";
        el.addLabel.value = details.label || "";
        el.addSubtitle.value = details.subtitle || "";
        el.addTarget.value = details.target || "";
        el.addAction.value = details.action || "terminal";
        el.addArgs.value = formatArgs(details.args || []);
        el.addStartIn.value = details.startIn || "";
        el.addIconMode.value = details.iconMode || "emoji";
        el.addIconEmoji.value = details.iconMode === "emoji" ? (details.icon || "") : "";
        renderIconPresetMenu(details.type || "app");
        if (details.iconMode === "emoji" && details.icon) {
          const hasOption = Array.from(el.addIconPreset.options).some((opt) => opt.value === details.icon);
          if (hasOption) el.addIconPreset.value = details.icon;
        }
      }

      updateAddFormVisibility();
      el.dlgAdd.showModal();

      try {
        const suggested = await fetchPrograms(el.addType.value === "app" ? el.addTarget.value : "", 10);
        renderProgramSuggestions(suggested);
      } catch {
        el.rowProgramHints.hidden = true;
      }
    }
    async function refreshSettingsContent() {
      if (!state.token) {
        renderSettingsNeedToken();
        return;
      }

      try {
        const settings = await api("/api/settings");
        if (settingsStatus.token) settingsStatus.token.setBase(state.token);
        setFieldStatus(el.tokenStatus, { kind: "ok", text: "Token aktiv" });
        setAiUi(settings.ai || {});

        el.launchersBox.textContent = "";
        for (const launcher of settings.launchers || []) {
          const row = document.createElement("div");
          row.className = "setRow";

          const label = document.createElement("div");
          label.className = "setLabel";
          label.textContent = `${launcher.label} (${launcher.id})`;
          row.appendChild(label);

          const input = document.createElement("input");
          input.value = launcher.path || "";
          input.placeholder = "Pfad";
          row.appendChild(input);
          const launcherStatus = createRowStatusController(
            row,
            input,
            (value) => validatePathField(value, { required: true, emptyText: "Kein Launcher-Pfad gesetzt" }),
            { changedText: "Launcher geaendert, noch nicht gespeichert" }
          );

          const buttons = document.createElement("div");
          buttons.className = "setButtons";

          const btnBrowse = document.createElement("button");
          btnBrowse.className = "btn";
          btnBrowse.type = "button";
          btnBrowse.textContent = "Browse";
          btnBrowse.onclick = async () => {
            try {
              const r = await api("/api/settings/browse", { method: "POST", body: { kind: "file", title: `${launcher.label} waehlen` } });
              if (r.path) {
                input.value = r.path;
                await api("/api/settings/launcher", { method: "POST", body: { id: launcher.id, path: r.path } });
                launcherStatus.markSaved();
                showToast(`${launcher.label} gesetzt`);
              } else if (r.unavailable) {
                showToast(r.reason || "Datei-Dialog nicht verfuegbar. Pfad manuell eintragen.");
              }
            } catch (error) {
              showToast(`Browse Fehler: ${error.message || String(error)}`);
            }
          };

          const btnAuto = document.createElement("button");
          btnAuto.className = "btn";
          btnAuto.type = "button";
          btnAuto.textContent = "Auto";
          btnAuto.onclick = async () => {
            try {
              await api("/api/settings/autodetect", { method: "POST", body: { launcherId: launcher.id } });
              await refreshSettingsContent();
              showToast(`${launcher.label} automatisch geprueft`);
            } catch (error) {
              showToast(`Auto Fehler: ${error.message || String(error)}`);
            }
          };

          const btnSave = document.createElement("button");
          btnSave.className = "btn primary";
          btnSave.type = "button";
          btnSave.textContent = "Speichern";
          btnSave.onclick = async () => {
            try {
              await api("/api/settings/launcher", { method: "POST", body: { id: launcher.id, path: input.value } });
              launcherStatus.markSaved();
              showToast(`${launcher.label} gespeichert`);
            } catch (error) {
              showToast(`Speichern fehlgeschlagen: ${error.message || String(error)}`);
            }
          };

          buttons.appendChild(btnBrowse);
          buttons.appendChild(btnAuto);
          buttons.appendChild(btnSave);
          row.appendChild(buttons);
          el.launchersBox.appendChild(row);
        }

        el.wowBox.textContent = "";
        const folders = settings.wow && settings.wow.folders ? settings.wow.folders : {};
        const keys = ["addons", "logs", "wtf"];
        for (const key of keys) {
          const row = document.createElement("div");
          row.className = "setRow";

          const label = document.createElement("div");
          label.className = "setLabel";
          label.textContent = `WoW ${key}`;
          row.appendChild(label);

          const input = document.createElement("input");
          input.value = folders[key] || "";
          row.appendChild(input);
          const wowFolderStatus = createRowStatusController(
            row,
            input,
            (value) => validatePathField(value, { required: true, emptyText: `WoW ${key} Pfad fehlt` }),
            { changedText: `WoW ${key} geaendert, noch nicht gespeichert` }
          );

          const buttons = document.createElement("div");
          buttons.className = "setButtons";

          const btnBrowse = document.createElement("button");
          btnBrowse.className = "btn";
          btnBrowse.type = "button";
          btnBrowse.textContent = "Browse";
          btnBrowse.onclick = async () => {
            try {
              const r = await api("/api/settings/browse", { method: "POST", body: { kind: "folder", title: `WoW ${key} Ordner` } });
              if (r.path) {
                input.value = r.path;
                await api("/api/settings/wow-folder", { method: "POST", body: { key, path: r.path } });
                wowFolderStatus.markSaved();
                showToast(`WoW ${key} gesetzt`);
              } else if (r.unavailable) {
                showToast(r.reason || "Ordner-Dialog nicht verfuegbar. Pfad manuell eintragen.");
              }
            } catch (error) {
              showToast(`Browse Fehler: ${error.message || String(error)}`);
            }
          };

          const btnSave = document.createElement("button");
          btnSave.className = "btn primary";
          btnSave.type = "button";
          btnSave.textContent = "Speichern";
          btnSave.onclick = async () => {
            try {
              await api("/api/settings/wow-folder", { method: "POST", body: { key, path: input.value } });
              wowFolderStatus.markSaved();
              showToast(`WoW ${key} gespeichert`);
            } catch (error) {
              showToast(`Speichern fehlgeschlagen: ${error.message || String(error)}`);
            }
          };

          buttons.appendChild(btnBrowse);
          buttons.appendChild(btnSave);
          row.appendChild(buttons);
          el.wowBox.appendChild(row);
        }

        const procRow = document.createElement("div");
        procRow.className = "setRow";
        const procLabel = document.createElement("div");
        procLabel.className = "setLabel";
        procLabel.textContent = "WoW Prozessname";
        procRow.appendChild(procLabel);
        const procInput = document.createElement("input");
        procInput.value = settings.wow?.processName || "WowClassic.exe";
        procRow.appendChild(procInput);
        const wowProcessStatus = createRowStatusController(
          procRow,
          procInput,
          validateWowProcessField,
          { changedText: "Prozessname geaendert, noch nicht gespeichert" }
        );
        const procButtons = document.createElement("div");
        procButtons.className = "setButtons";
        const procSave = document.createElement("button");
        procSave.className = "btn primary";
        procSave.type = "button";
        procSave.textContent = "Speichern";
        procSave.onclick = async () => {
          try {
            await api("/api/settings/wow-process", { method: "POST", body: { processName: procInput.value } });
            wowProcessStatus.markSaved();
            showToast("WoW Prozess gespeichert");
          } catch (error) {
            showToast(`Speichern fehlgeschlagen: ${error.message || String(error)}`);
          }
        };
        procButtons.appendChild(procSave);
        procRow.appendChild(procButtons);
        el.wowBox.appendChild(procRow);

        el.hiddenBox.textContent = "";
        if (!state.hidden.size) {
          const msg = document.createElement("div");
          msg.className = "setLabel";
          msg.textContent = "Keine ausgeblendeten Tiles.";
          el.hiddenBox.appendChild(msg);
        } else {
          const tileMap = new Map(state.tiles.map((t) => [t.id, t]));
          for (const id of Array.from(state.hidden)) {
            const row = document.createElement("div");
            row.className = "setRow";
            const label = document.createElement("div");
            label.className = "setLabel";
            label.textContent = tileMap.get(id)?.label || id;
            row.appendChild(label);
            const btn = document.createElement("button");
            btn.className = "btn";
            btn.type = "button";
            btn.textContent = "Einblenden";
            btn.onclick = async () => {
              state.hidden.delete(id);
              saveSet(LS.hidden, state.hidden);
              renderTiles();
              await refreshSettingsContent();
            };
            row.appendChild(btn);
            el.hiddenBox.appendChild(row);
          }
        }

        setLoggingUi(settings.logging || {});
        refreshStaticSettingsStatusControllers();
        const hasConfigTransfer = settings.features?.settingsImportExport === true;
        el.cfgExport.disabled = !hasConfigTransfer;
        el.cfgImport.disabled = !hasConfigTransfer;
        el.cfgImportFile.disabled = !hasConfigTransfer;
        if (!hasConfigTransfer) {
          el.cfgMeta.textContent = "Config-Import/Export ist auf diesem Server nicht verfuegbar.";
        }
        try {
          await loadRecentLogs();
        } catch (error) {
          el.logMeta.textContent = `Logs konnten nicht geladen werden: ${error.message || String(error)}`;
          el.logView.textContent = "";
        }
      } catch (error) {
        el.launchersBox.textContent = "";
        setFieldStatus(el.tokenStatus, { kind: "err", text: "Token ungueltig oder Server nicht erreichbar" });
        el.aiMeta.textContent = `Konnte KI-Einstellungen nicht laden: ${error.message || String(error)}`;
        el.aiModel.disabled = true;
        el.aiApiKey.disabled = true;
        el.aiSave.disabled = true;
        el.aiClear.disabled = true;
        el.stickySaveAi.disabled = true;
        el.stickySaveLogging.disabled = true;
        const msg = document.createElement("div");
        msg.className = "setLabel";
        msg.textContent = `Konnte Einstellungen nicht laden: ${error.message || String(error)}`;
        el.launchersBox.appendChild(msg);
        el.logMeta.textContent = `Konnte Logs nicht laden: ${error.message || String(error)}`;
        el.logView.textContent = "";
      }
    }

    async function exportConfigSnapshot() {
      try {
        const data = await api("/api/settings/export");
        if (!data || !data.config) throw new Error("Keine Config-Daten vom Server erhalten");
        const fileName = formatExportFileName("streamdeck_remote-config");
        downloadJsonFile(fileName, data.config);
        el.cfgMeta.textContent = `Export erfolgreich: ${fileName}`;
      } catch (error) {
        if (isHttp404Error(error)) {
          showLegacyServerHint("/api/settings/export");
          throw new Error("Config-Export-Endpunkt fehlt auf dem laufenden Server. Bitte Server neu starten.");
        }
        throw error;
      }
    }

    function readJsonFile(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
          try {
            const text = String(reader.result || "");
            const parsed = JSON.parse(text);
            resolve(parsed);
          } catch (error) {
            reject(new Error(`JSON ungültig: ${error.message || String(error)}`));
          }
        };
        reader.onerror = () => reject(new Error("Datei konnte nicht gelesen werden"));
        reader.readAsText(file, "utf-8");
      });
    }

    async function importConfigSnapshotFromFile(file) {
      if (!file) throw new Error("Datei fehlt");
      const parsed = await readJsonFile(file);
      if (!parsed || typeof parsed !== "object" || Array.isArray(parsed)) {
        throw new Error("Datei muss ein JSON-Objekt enthalten");
      }

      const confirmed = window.confirm("Import ersetzt Profile/Tiles/Settings. Fortfahren?");
      if (!confirmed) return false;

      try {
        const result = await api("/api/settings/import", {
          method: "POST",
          body: { config: parsed, keepCurrentToken: true }
        });
        await loadBootstrap();
        await pollStatus();
        await refreshSettingsContent();
        const summary = result?.summary || {};
        el.cfgMeta.textContent = `Import erfolgreich: ${summary.profiles || 0} Profile, ${summary.tiles || 0} Tiles`;
        if (result?.restartRequired) {
          showToast("Import gespeichert. Host/Port wurden geaendert - bitte Server neu starten.");
        }
        return true;
      } catch (error) {
        if (isHttp404Error(error)) {
          showLegacyServerHint("/api/settings/import");
          throw new Error("Config-Import-Endpunkt fehlt auf dem laufenden Server. Bitte Server neu starten.");
        }
        throw error;
      }
    }

    async function openSettingsDialog() {
      el.tokenInput.value = state.token;
      if (settingsStatus.token) settingsStatus.token.setBase(state.token);
      await refreshSettingsContent();
      if (!el.dlgSettings.open) el.dlgSettings.showModal();
    }

    async function saveAiSettings(options = {}) {
      const clearKey = options.clearKey === true;
      const modelInput = String(el.aiModel.value || "").trim();
      const model = modelInput || "gpt-4o-mini";
      const keyInput = String(el.aiApiKey.value || "").trim();
      const payload = { model };
      if (clearKey) {
        payload.openAiApiKey = "";
      } else if (keyInput) {
        payload.openAiApiKey = keyInput;
        payload.verify = true;
      }
      let result = null;
      try {
        result = await api("/api/settings/ai", { method: "POST", body: payload });
      } catch (error) {
        if (isHttp404Error(error)) {
          showLegacyServerHint("/api/settings/ai");
          throw new Error("KI-Settings-Endpunkt fehlt auf dem laufenden Server. Bitte Server neu starten.");
        }
        throw error;
      }
      setAiUi(result.ai || {});
      return result;
    }

    bindStaticSettingsStatusControllers();

    el.clearQ.addEventListener("click", () => {
      el.q.value = "";
      renderTiles();
    });
    el.q.addEventListener("input", renderTiles);

    el.profileTabs.addEventListener("click", (event) => {
      const btn = event.target.closest("button.tab[data-profile]");
      if (!btn) return;
      state.profile = btn.dataset.profile;
      const pages = pagesForProfile(state.profile);
      state.page = pages[0]?.id || "main";
      localStorage.setItem(LS.profile, state.profile);
      localStorage.setItem(LS.page, state.page);
      renderTiles();
    });

    el.pageTabs.addEventListener("click", (event) => {
      const btn = event.target.closest("button.tab[data-page]");
      if (!btn) return;
      state.page = btn.dataset.page;
      localStorage.setItem(LS.page, state.page);
      renderTiles();
    });

    function clearLongPress() {
      if (state.longPressTimer) clearTimeout(state.longPressTimer);
      state.longPressTimer = null;
      state.longPressTileId = "";
    }

    document.addEventListener("pointerdown", (event) => {
      const btn = event.target.closest("button.tile[data-id]");
      if (!btn) return;
      state.longPressTileId = btn.dataset.id;
      state.longPressTimer = setTimeout(() => {
        state.longPressTimer = null;
        openTileMenuById(state.longPressTileId);
      }, 450);
    });

    document.addEventListener("pointerup", clearLongPress);
    document.addEventListener("pointercancel", clearLongPress);
    document.addEventListener("pointerleave", clearLongPress);
    window.addEventListener("blur", clearLongPress);

    document.addEventListener("pointermove", (event) => {
      if (!state.longPressTimer) return;
      if (Math.abs(event.movementX) + Math.abs(event.movementY) > 8) {
        clearTimeout(state.longPressTimer);
        state.longPressTimer = null;
      }
    });

    document.addEventListener("click", (event) => {
      const btn = event.target.closest("button.tile[data-id]");
      if (!btn || el.dlgTile.open) return;
      runTile(btn.dataset.id);
    });

    document.addEventListener("contextmenu", (event) => {
      const btn = event.target.closest("button.tile[data-id]");
      if (!btn) return;
      event.preventDefault();
      openTileMenuById(btn.dataset.id);
    });

    document.addEventListener("keydown", (event) => {
      const target = event.target;
      if (!(target instanceof HTMLElement)) return;
      const btn = target.closest("button.tile[data-id]");
      if (!btn) return;
      const isContextKey = event.key === "ContextMenu" || (event.shiftKey && event.key === "F10");
      if (!isContextKey) return;
      event.preventDefault();
      openTileMenuById(btn.dataset.id);
    });

    document.addEventListener("keydown", async (event) => {
      const key = String(event.key || "");
      const keyLower = key.toLowerCase();
      const meta = event.metaKey || event.ctrlKey;
      const editable = isEditableElement(event.target);

      if (meta && keyLower === "k") {
        event.preventDefault();
        el.q.focus();
        el.q.select();
        return;
      }

      if (meta && key === ",") {
        event.preventDefault();
        await openSettingsDialog();
        return;
      }

      if (meta && event.shiftKey && keyLower === "a") {
        event.preventDefault();
        if (!state.token) {
          showToast("Bitte zuerst Token setzen");
          await openSettingsDialog();
          return;
        }
        try {
          await openAddDialog();
        } catch (error) {
          showToast(`Dialog konnte nicht geoeffnet werden: ${error.message || String(error)}`);
        }
        return;
      }

      const anyDialogOpen = el.dlgAdd.open || el.dlgSettings.open || el.dlgTile.open || el.dlgOverlay.open;
      if (!editable && !anyDialogOpen && event.altKey && !meta && !event.shiftKey && /^[1-9]$/.test(key)) {
        event.preventDefault();
        const idx = Number(key) - 1;
        const visible = currentTiles();
        const tile = visible[idx];
        if (tile) runTile(tile.id);
        return;
      }

      if (key === "Escape") {
        if (el.dlgTile.open) {
          el.dlgTile.close();
          return;
        }
        if (el.dlgAdd.open) {
          el.dlgAdd.close();
          return;
        }
        if (el.dlgOverlay.open) {
          closeEmbeddedOverlay({ goMain: false });
          return;
        }
      }
    });

    el.btnAdd.addEventListener("click", () => {
      if (!state.token) {
        showToast("Bitte zuerst Token setzen");
        openSettingsDialog();
        return;
      }
      openAddDialog().catch((error) => {
        showToast(`Dialog konnte nicht geoeffnet werden: ${error.message || String(error)}`);
      });
    });

    el.quickProgramAdd.addEventListener("click", async () => {
      try {
        await quickAddProgram(el.quickProgramInput.value);
        el.quickProgramInput.value = "";
      } catch (error) {
        showToast(`Quick-Add fehlgeschlagen: ${error.message || String(error)}`);
      }
    });

    el.quickProgramInput.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        event.preventDefault();
        el.quickProgramAdd.click();
      }
    });

    el.addProfile.addEventListener("change", () => {
      fillPageSelect(el.addProfile.value, el.addPage);
    });
    el.addType.addEventListener("change", async () => {
      updateAddFormVisibility();
      renderIconPresetMenu(el.addType.value);
      el.addIconPreset.value = "";
      if (el.addType.value === "app") {
        try {
          const programs = await fetchPrograms(el.addTarget.value, 10);
          renderProgramSuggestions(programs);
        } catch {
          renderProgramSuggestions([]);
        }
      }
    });
    el.addIconMode.addEventListener("change", updateAddFormVisibility);
    el.addIconPresetApply.addEventListener("click", () => {
      try {
        applyIconPreset(el.addIconPreset.value);
        showToast(`Icon gesetzt: ${el.addIconPreset.value}`);
      } catch (error) {
        showToast(error.message || String(error));
      }
    });
    el.addIconPreset.addEventListener("change", () => {
      if (!el.addIconPreset.value) return;
      try {
        applyIconPreset(el.addIconPreset.value);
      } catch {
        // no-op
      }
    });

    el.addBrowse.addEventListener("click", async () => {
      const kind = el.addBrowse.dataset.kind || "file";
      try {
        const result = await api("/api/settings/browse", { method: "POST", body: { kind } });
        if (result.path) {
          el.addTarget.value = result.path;
          if (el.addType.value === "app") {
            if (!el.addLabel.value.trim()) el.addLabel.value = inferProgramLabel(result.path);
            renderProgramSuggestions([{ label: inferProgramLabel(result.path), path: result.path, source: "browse" }]);
          }
        } else if (result.unavailable) {
          showToast(result.reason || "Datei-/Ordner-Dialog nicht verfuegbar. Ziel bitte manuell eingeben.");
        }
      } catch (error) {
        showToast(`Browse Fehler: ${error.message || String(error)}`);
      }
    });

    el.addTarget.addEventListener("input", () => {
      if (el.addType.value !== "app") return;
      if (state.addProgramSearchTimer) clearTimeout(state.addProgramSearchTimer);
      state.addProgramSearchTimer = setTimeout(async () => {
        try {
          const programs = await fetchPrograms(el.addTarget.value, 8);
          renderProgramSuggestions(programs);
        } catch {
          renderProgramSuggestions([]);
        }
      }, 220);
    });

    el.addFindProgram.addEventListener("click", async () => {
      try {
        const query = String(el.addTarget.value || "").trim() || String(el.addLabel.value || "").trim();
        if (!query) throw new Error("Bitte Programmname oder Pfad eingeben");
        const splitInput = splitAppTargetInput(query);
        const targetInput = splitInput.target || query;
        const resolved = await resolveProgramInput(targetInput, { allowDirectPathFallback: true });
        el.addTarget.value = resolved;
        if (splitInput.inlineArgs.length) {
          const mergedArgs = [...splitInput.inlineArgs, ...parseArgs(el.addArgs.value)];
          el.addArgs.value = formatArgs(mergedArgs);
        }
        if (!el.addLabel.value.trim()) el.addLabel.value = inferProgramLabel(resolved);
        const programs = await fetchPrograms(query, 8);
        renderProgramSuggestions(programs);
        showToast(`Programm gefunden: ${resolved}`);
      } catch (error) {
        showToast(`Suche fehlgeschlagen: ${error.message || String(error)}`);
      }
    });

    el.addTopPrograms.addEventListener("click", async () => {
      try {
        const programs = await fetchPrograms("", 16);
        renderProgramSuggestions(programs);
      } catch (error) {
        showToast(`Programmliste konnte nicht geladen werden: ${error.message || String(error)}`);
      }
    });

    el.addCancel.addEventListener("click", () => {
      state.editingTileId = "";
      state.editingTileIconData = "";
      el.dlgAdd.close();
    });
    el.dlgAdd.addEventListener("close", () => {
      state.editingTileId = "";
      state.editingTileIconData = "";
      setAddDialogMode(false);
    });

    el.addSave.addEventListener("click", async () => {
      try {
        const type = el.addType.value;
        const profile = el.addProfile.value;
        const page = el.addPage.value;
        const rawTarget = String(el.addTarget.value || "").trim();
        let label = String(el.addLabel.value || "").trim();
        const subtitle = String(el.addSubtitle.value || "").trim();
        if (type === "app" && !label) label = inferProgramLabel(rawTarget);
        if (!profile || !page || !label) throw new Error("Profil, Seite und Titel sind Pflicht");

        const tile = {
          profile,
          page,
          label,
          subtitle,
          type,
          iconMode: el.addIconMode.value,
          icon: "",
          iconData: ""
        };
        if (state.editingTileId) tile.id = state.editingTileId;

        if (tile.iconMode === "emoji") tile.icon = String(el.addIconEmoji.value || "").trim();
        if (tile.iconMode === "image") {
          const uploadedIcon = await readImageDataUrl(el.addIconFile.files && el.addIconFile.files[0]);
          tile.iconData = uploadedIcon || state.editingTileIconData || "";
          if (!tile.iconData) throw new Error("Bitte eine Bilddatei waehlen");
        }

        if (type === "action") {
          tile.action = el.addAction.value;
        } else {
          tile.target = rawTarget;
          if (!tile.target) throw new Error("Ziel fehlt");
        }

        if (type === "url") {
          const normalized = tile.target.includes("://") ? tile.target : `https://${tile.target}`;
          const check = new URL(normalized);
          if (!["http:", "https:"].includes(check.protocol)) throw new Error("Nur http/https erlaubt");
          tile.target = check.toString();
        }

        if (type === "protocol") {
          if (!/^[a-z][a-z0-9+.-]*:[^\s]*$/i.test(tile.target)) {
            throw new Error("Ungueltiges Protocol-Schema");
          }
        }

        if (type === "app") {
          const splitInput = splitAppTargetInput(tile.target);
          tile.target = splitInput.target || tile.target;
          try {
            tile.target = await resolveProgramInput(tile.target, { allowDirectPathFallback: true });
          } catch (error) {
            if (looksLikePathInput(tile.target)) {
              tile.target = unquoteInput(tile.target);
              showToast("Hinweis: Programm konnte nicht auto-aufgeloest werden. Pfad wird direkt gespeichert.");
            } else {
              throw error;
            }
          }
          tile.args = [...splitInput.inlineArgs, ...parseArgs(el.addArgs.value)];
          const startIn = String(el.addStartIn.value || "").trim();
          if (startIn) tile.startIn = startIn;
        }

        await api("/api/tiles/upsert", { method: "POST", body: { tile } });
        el.dlgAdd.close();
        const wasEditing = Boolean(state.editingTileId);
        state.editingTileId = "";
        state.editingTileIconData = "";
        await loadBootstrap();
        showToast(wasEditing ? "Tile aktualisiert" : "Tile gespeichert");
      } catch (error) {
        showToast(`Speichern fehlgeschlagen: ${error.message || String(error)}`);
      }
    });

    el.btnSettings.addEventListener("click", openSettingsDialog);
    el.btnShortcuts.addEventListener("click", () => {
      showToast("Shortcuts: Ctrl+K Suche | Ctrl+Shift+A Neues Tile | Ctrl+, Einstellungen | Alt+1..9 Tile starten");
    });
    el.settingsClose.addEventListener("click", () => el.dlgSettings.close());
    el.stickyCloseSettings.addEventListener("click", () => el.dlgSettings.close());
    el.stickySaveToken.addEventListener("click", () => el.saveToken.click());
    el.stickySaveAi.addEventListener("click", () => el.aiSave.click());
    el.stickySaveLogging.addEventListener("click", () => el.logSave.click());
    el.overlayClose.addEventListener("click", () => closeEmbeddedOverlay({ goMain: false }));
    el.overlayBack.addEventListener("click", () => closeEmbeddedOverlay({ goMain: true }));
    el.dlgOverlay.addEventListener("close", () => {
      state.overlayContext = null;
      if (el.overlayFrame.src && !el.overlayFrame.src.endsWith("about:blank")) {
        el.overlayFrame.src = "about:blank";
      }
    });
    el.overlayFrame.addEventListener("load", () => {
      try {
        if (!state.token || !el.overlayFrame.contentWindow) return;
        el.overlayFrame.contentWindow.localStorage.setItem(LS.token, state.token);
      } catch {
        // ignore frame access issues
      }
    });
    window.addEventListener("message", (event) => {
      if (event.origin !== window.location.origin) return;
      const msg = event.data && typeof event.data === "object" ? event.data : null;
      if (!msg || msg.source !== "streamdeck-overlay") return;
      if (msg.type === "close") closeEmbeddedOverlay({ goMain: false });
      if (msg.type === "back-main") closeEmbeddedOverlay({ goMain: true });
      if (msg.type === "open-settings") {
        closeEmbeddedOverlay({ goMain: true });
        openSettingsDialog().catch((error) => {
          showToast(`Einstellungen konnten nicht geoeffnet werden: ${error.message || String(error)}`);
        });
      }
    });

    el.saveToken.addEventListener("click", async () => {
      state.token = String(el.tokenInput.value || "").trim();
      const tokenStatus = validateTokenField(state.token);
      setFieldStatus(el.tokenStatus, tokenStatus);
      if (tokenStatus.kind === "err") {
        showToast(tokenStatus.text);
        return;
      }
      localStorage.setItem(LS.token, state.token);
      try {
        await loadBootstrap();
        await pollStatus();
        if (settingsStatus.token) settingsStatus.token.markSaved();
        setFieldStatus(el.tokenStatus, { kind: "ok", text: "Token gespeichert und verifiziert" });
        showToast("Token gespeichert");
      } catch (error) {
        setFieldStatus(el.tokenStatus, { kind: "err", text: "Token ungueltig oder Server nicht erreichbar" });
        showToast(`Laden fehlgeschlagen: ${error.message || String(error)}`);
      }
    });

    el.testToken.addEventListener("click", async () => {
      state.token = String(el.tokenInput.value || "").trim();
      if (!state.token) {
        setFieldStatus(el.tokenStatus, { kind: "err", text: "Token fehlt" });
        showToast("Token fehlt");
        return;
      }
      try {
        await api("/api/health");
        setFieldStatus(el.tokenStatus, { kind: "ok", text: "Token-Test erfolgreich" });
        showToast("Token ist gueltig");
      } catch (error) {
        setFieldStatus(el.tokenStatus, { kind: "err", text: "Token-Test fehlgeschlagen" });
        showToast(`Token ungueltig: ${error.message || String(error)}`);
      }
    });

    el.aiSave.addEventListener("click", async () => {
      const modelStatus = validateAiModelField(el.aiModel.value);
      if (modelStatus.kind === "err") {
        setFieldStatus(el.aiModelStatus, modelStatus);
        showToast(modelStatus.text);
        return;
      }
      const keyStatus = validateAiApiKeyField(el.aiApiKey.value);
      if (keyStatus.kind === "err") {
        setFieldStatus(el.aiApiKeyStatus, keyStatus);
        showToast(keyStatus.text);
        return;
      }
      try {
        const result = await saveAiSettings({ clearKey: false });
        if (settingsStatus.aiModel) settingsStatus.aiModel.markSaved();
        if (result?.verification?.ok === true) {
          const modelCount = Number(result.verification.modelCount) || 0;
          showToast(`KI gespeichert (OpenAI verifiziert, Modelle: ${modelCount})`);
        } else {
          showToast("KI-Einstellungen gespeichert");
        }
      } catch (error) {
        showToast(`KI speichern fehlgeschlagen: ${error.message || String(error)}`);
      }
    });

    el.aiClear.addEventListener("click", async () => {
      const confirmed = window.confirm("Gespeicherten OpenAI API-Key wirklich entfernen?");
      if (!confirmed) return;
      try {
        await saveAiSettings({ clearKey: true });
        if (settingsStatus.aiApiKey) settingsStatus.aiApiKey.markSaved();
        setFieldStatus(el.aiApiKeyStatus, { kind: "info", text: "API-Key entfernt (Fallback aktiv)" });
        showToast("OpenAI API-Key entfernt");
      } catch (error) {
        showToast(`API-Key entfernen fehlgeschlagen: ${error.message || String(error)}`);
      }
    });

    el.refreshAll.addEventListener("click", async () => {
      try {
        await loadBootstrap();
        await pollStatus();
        showToast("Neu geladen");
      } catch (error) {
        showToast(`Neu laden fehlgeschlagen: ${error.message || String(error)}`);
      }
    });

    el.autoDetectAll.addEventListener("click", async () => {
      try {
        await api("/api/settings/autodetect", { method: "POST", body: {} });
        await refreshSettingsContent();
        showToast("Auto-Erkennung ausgefuehrt");
      } catch (error) {
        showToast(`Auto-Erkennung fehlgeschlagen: ${error.message || String(error)}`);
      }
    });

    el.logsRefresh.addEventListener("click", async () => {
      try {
        await loadRecentLogs();
        showToast("Logs geladen");
      } catch (error) {
        showToast(`Logs laden fehlgeschlagen: ${error.message || String(error)}`);
      }
    });

    el.logLines.addEventListener("change", async () => {
      if (!el.dlgSettings.open || !state.token) return;
      try {
        await loadRecentLogs();
      } catch {
        // ignore on quick line-count changes
      }
    });

    el.logsCopy.addEventListener("click", async () => {
      const text = String(el.logView.textContent || "").trim();
      if (!text) {
        showToast("Keine Logs zum Kopieren");
        return;
      }
      try {
        if (navigator.clipboard?.writeText) {
          await navigator.clipboard.writeText(text);
        } else {
          const tmp = document.createElement("textarea");
          tmp.value = text;
          document.body.appendChild(tmp);
          tmp.select();
          document.execCommand("copy");
          tmp.remove();
        }
        showToast("Logs kopiert");
      } catch (error) {
        showToast(`Kopieren fehlgeschlagen: ${error.message || String(error)}`);
      }
    });

    el.logSave.addEventListener("click", async () => {
      const maxFilesStatus = validateLogMaxFilesField(el.logMaxFiles.value);
      if (maxFilesStatus.kind === "err") {
        setFieldStatus(el.logMaxFilesStatus, maxFilesStatus);
        showToast(maxFilesStatus.text);
        return;
      }
      const dirStatus = validateLogDirField(el.logDir.value);
      if (dirStatus.kind === "err") {
        setFieldStatus(el.logDirStatus, dirStatus);
        showToast(dirStatus.text);
        return;
      }
      try {
        await api("/api/settings/logging", {
          method: "POST",
          body: {
            enabled: el.logEnabled.value === "true",
            level: String(el.logLevel.value || "INFO").toUpperCase(),
            maxFiles: Number(el.logMaxFiles.value) || 14,
            dir: String(el.logDir.value || "").trim()
          }
        });
        await refreshSettingsContent();
        if (settingsStatus.logMaxFiles) settingsStatus.logMaxFiles.markSaved();
        if (settingsStatus.logDir) settingsStatus.logDir.markSaved();
        showToast("Logging gespeichert");
      } catch (error) {
        showToast(`Logging speichern fehlgeschlagen: ${error.message || String(error)}`);
      }
    });

    el.cfgExport.addEventListener("click", async () => {
      try {
        await exportConfigSnapshot();
        showToast("Config exportiert");
      } catch (error) {
        showToast(`Config-Export fehlgeschlagen: ${error.message || String(error)}`);
      }
    });

    el.cfgImport.addEventListener("click", () => {
      if (!state.token) {
        showToast("Bitte zuerst Token setzen");
        return;
      }
      el.cfgImportFile.value = "";
      el.cfgImportFile.click();
    });

    el.cfgImportFile.addEventListener("change", async () => {
      const file = el.cfgImportFile.files && el.cfgImportFile.files[0];
      if (!file) return;
      try {
        const changed = await importConfigSnapshotFromFile(file);
        if (changed) showToast("Config importiert");
      } catch (error) {
        showToast(`Config-Import fehlgeschlagen: ${error.message || String(error)}`);
      } finally {
        el.cfgImportFile.value = "";
      }
    });

    document.addEventListener("visibilitychange", () => {
      if (document.hidden || !state.token) return;
      pollStatus().catch(() => setApiState("offline", "err"));
      loadBootstrap().catch(() => setApiState("offline", "err"));
    });

    async function init() {
      if (!state.token) {
        setApiState("token?", "");
        setWowState("unknown", "");
        renderTiles();
        openSettingsDialog();
        return;
      }

      try {
        await loadBootstrap();
        await pollStatus();
      } catch (error) {
        showToast(`Init Fehler: ${error.message || String(error)}`);
        setApiState("offline", "err");
      }

      if (state.pendingPanel) {
        const panel = state.pendingPanel;
        state.pendingPanel = "";
        openEmbeddedPanel(panel, { profile: state.profile });
        try {
          const clean = new URL(window.location.href);
          clean.searchParams.delete("panel");
          history.replaceState({}, "", `${clean.pathname}${clean.search}`);
        } catch {
          // ignore history mutation issues
        }
      }

      if (state.serverBuild) {
        console.info(`StreamDeck UI ${CLIENT_BUILD} | Server ${state.serverVersion || "?"} (${state.serverBuild})`);
      }

      if (state.pollTimer) clearInterval(state.pollTimer);
      state.bootstrapTick = 0;
      state.pollTimer = setInterval(async () => {
        try {
          await pollStatus();
          if (state.bootstrapTick % 3 === 0) {
            await loadBootstrap();
          }
          state.bootstrapTick += 1;
        } catch {
          setApiState("offline", "err");
        }
      }, 5000);
    }

    init();
  </script>
</body>
</html>
