<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>StreamDeck Remote</title>

  <link rel="manifest" href="/manifest.webmanifest" />
  <meta name="theme-color" content="#101821" />

  <style>
    :root {
      --bg0: #05101a;
      --bg1: #0d1f2f;
      --bg2: #133a54;
      --card: rgba(9, 20, 33, 0.74);
      --line: rgba(189, 220, 255, 0.23);
      --lineStrong: rgba(189, 220, 255, 0.4);
      --text: rgba(239, 249, 255, 0.98);
      --muted: rgba(205, 227, 246, 0.78);
      --ok: #22c55e;
      --warn: #f59e0b;
      --err: #ef4444;
      --accent: #5dd8ff;
      --radius: 18px;
      --shadow: 0 24px 60px rgba(0, 0, 0, 0.45);
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }

    body {
      margin: 0;
      color: var(--text);
      font-family: "Segoe UI Variable", "Segoe UI", "Noto Sans", sans-serif;
      background:
        radial-gradient(1200px 620px at 8% 3%, rgba(59,130,246,.22), transparent 63%),
        radial-gradient(1200px 650px at 90% 4%, rgba(14,165,233,.2), transparent 62%),
        linear-gradient(170deg, var(--bg0), var(--bg1) 46%, var(--bg2));
    }

    .app {
      min-height: 100%;
      padding: 14px;
      display: grid;
      place-items: start center;
    }

    .panel {
      width: min(1280px, 100%);
      border: 1px solid var(--line);
      border-radius: calc(var(--radius) + 8px);
      background: var(--card);
      backdrop-filter: blur(16px);
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    header {
      padding: 14px;
      display: grid;
      gap: 12px;
      border-bottom: 1px solid var(--line);
      background: linear-gradient(180deg, rgba(146, 201, 255, 0.16), rgba(30, 54, 74, 0.28));
    }

    .headTop {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 14px;
      flex-wrap: wrap;
    }

    .brand {
      display: grid;
      gap: 5px;
    }

    .brand strong { font-size: 18px; letter-spacing: .2px; }
    .brand span { font-size: 12px; color: var(--muted); }

    .headActions {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    .chip {
      border: 1px solid var(--line);
      background: rgba(2, 10, 17, 0.42);
      padding: 9px 12px;
      border-radius: 999px;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      color: rgba(228, 244, 255, 0.96);
      font-size: 12px;
      min-height: 38px;
    }

    .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--warn);
      box-shadow: 0 0 0 3px rgba(245, 158, 11, 0.2);
    }

    .dot.ok { background: var(--ok); box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.2); }
    .dot.err { background: var(--err); box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.2); }

    .btn {
      border: 1px solid var(--line);
      border-radius: 12px;
      background: rgba(193, 226, 255, 0.1);
      color: var(--text);
      padding: 10px 14px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      min-height: 42px;
    }

    .btn.primary {
      border-color: rgba(93, 216, 255, 0.62);
      background: linear-gradient(180deg, rgba(93, 216, 255, 0.28), rgba(93, 216, 255, 0.1));
    }
    .btn.warn { border-color: rgba(245, 158, 11, 0.45); }
    .btn.danger { border-color: rgba(239, 68, 68, 0.5); }

    .toolbar {
      display: grid;
      gap: 10px;
    }

    .topMenu {
      display: grid;
      gap: 10px;
      grid-template-columns: minmax(260px, 1fr) minmax(260px, 1fr);
    }

    .quickProgram {
      border: 1px solid var(--line);
      background: rgba(1, 9, 15, 0.4);
      border-radius: 16px;
      padding: 8px;
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .quickProgram input {
      width: 100%;
      border: 0;
      background: transparent;
      color: var(--text);
      outline: 0;
      padding: 8px;
      font-size: 13px;
    }

    .tabs {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .tab {
      border: 1px solid var(--line);
      background: rgba(0, 0, 0, 0.33);
      color: var(--text);
      border-radius: 999px;
      padding: 10px 13px;
      font-size: 13px;
      min-height: 42px;
      cursor: pointer;
      opacity: 0.88;
    }

    .tab[aria-selected="true"] {
      opacity: 1;
      border-color: var(--lineStrong);
      background: rgba(208, 233, 255, 0.2);
    }

    .searchRow {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
    }

    .search {
      display: flex;
      align-items: center;
      gap: 8px;
      min-width: min(520px, 100%);
      border: 1px solid var(--line);
      background: rgba(0, 0, 0, 0.34);
      border-radius: 999px;
      padding: 8px 11px;
    }

    .search input {
      width: 100%;
      border: 0;
      outline: 0;
      color: var(--text);
      background: transparent;
      font-size: 13px;
    }

    .content {
      padding: 14px;
      display: grid;
      gap: 14px;
    }

    .section {
      border: 1px solid var(--line);
      border-radius: var(--radius);
      overflow: hidden;
      background: rgba(255, 255, 255, 0.05);
    }

    .section h2 {
      margin: 0;
      padding: 10px 12px;
      font-size: 13px;
      color: var(--muted);
      border-bottom: 1px solid var(--line);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .grid {
      padding: 14px;
      display: grid;
      gap: 14px;
      grid-template-columns: repeat(auto-fit, minmax(210px, 1fr));
    }

    .tile {
      border: 1px solid var(--line);
      border-radius: 16px;
      background: linear-gradient(180deg, rgba(233, 245, 255, 0.18), rgba(177, 214, 246, 0.08));
      color: var(--text);
      min-height: 102px;
      padding: 14px;
      display: grid;
      grid-template-columns: 44px 1fr;
      gap: 11px;
      align-items: center;
      text-align: left;
      cursor: pointer;
      position: relative;
      box-shadow: 0 10px 24px rgba(0,0,0,.26);
      transition: transform .1s ease, border-color .1s ease;
    }

    .tile:hover { transform: translateY(-1px); border-color: rgba(255,255,255,.32); }
    .tile:active { transform: scale(.99); }
    .tile[disabled] { opacity: .58; cursor: not-allowed; }

    .iconWrap {
      width: 44px;
      height: 44px;
      border-radius: 12px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.22);
      display: grid;
      place-items: center;
      overflow: hidden;
      font-size: 21px;
    }

    .iconWrap img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .meta strong {
      display: block;
      font-size: 14px;
    }

    .meta span {
      display: block;
      margin-top: 4px;
      font-size: 12px;
      color: var(--muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .fav {
      position: absolute;
      right: 9px;
      top: 8px;
      font-size: 11px;
      opacity: .95;
    }

    .empty {
      padding: 28px;
      text-align: center;
      color: var(--muted);
      font-size: 13px;
    }

    .toast {
      position: fixed;
      right: 12px;
      bottom: 12px;
      max-width: min(540px, calc(100vw - 24px));
      background: rgba(0,0,0,.62);
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 12px;
      opacity: 0;
      transform: translateY(8px);
      transition: opacity .16s ease, transform .16s ease;
      pointer-events: none;
      word-break: break-word;
    }

    .toast.show { opacity: 1; transform: translateY(0); }

    dialog {
      border: 1px solid var(--line);
      border-radius: 14px;
      background: rgba(11, 16, 26, 0.98);
      color: var(--text);
      width: min(760px, calc(100vw - 20px));
      max-height: min(90vh, 860px);
      overflow: auto;
      padding: 12px;
    }

    dialog::backdrop { background: rgba(0,0,0,.58); }

    .dlgTitle { font-weight: 600; margin-bottom: 4px; }
    .dlgHint { color: var(--muted); font-size: 12px; margin-bottom: 8px; }

    .row {
      display: flex;
      gap: 9px;
      flex-wrap: wrap;
      align-items: center;
      margin: 9px 0;
    }

    .row > * { flex: 1; min-width: 180px; }

    .row input,
    .row select {
      width: 100%;
      border: 1px solid var(--line);
      border-radius: 10px;
      background: rgba(0,0,0,.24);
      color: var(--text);
      padding: 10px;
      outline: 0;
      font-size: 13px;
    }

    .rowActions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      margin-top: 10px;
      flex-wrap: wrap;
    }

    .setGroup {
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px;
      margin-top: 10px;
      background: rgba(0,0,0,.18);
      display: grid;
      gap: 8px;
    }

    .setRow {
      border: 1px solid rgba(255,255,255,.1);
      border-radius: 10px;
      padding: 8px;
      display: grid;
      gap: 7px;
      background: rgba(255,255,255,.03);
    }

    .setLabel {
      font-size: 12px;
      color: var(--muted);
    }

    .setButtons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .logMeta {
      font-size: 12px;
      color: var(--muted);
    }

    .logView {
      margin-top: 8px;
      border: 1px solid var(--line);
      border-radius: 10px;
      background: rgba(0, 0, 0, 0.35);
      max-height: 320px;
      overflow: auto;
      padding: 8px;
      font-family: "Cascadia Code", "Consolas", monospace;
      font-size: 11px;
      line-height: 1.45;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .hint {
      font-size: 12px;
      color: var(--muted);
    }

    #rowProgramHints {
      display: grid;
      gap: 8px;
      align-items: stretch;
    }

    #rowProgramHints > * {
      min-width: 0;
      flex: unset;
    }

    .suggestGrid {
      display: grid;
      gap: 8px;
      grid-template-columns: repeat(auto-fit, minmax(210px, 1fr));
    }

    .suggestBtn {
      border: 1px solid var(--line);
      background: rgba(0,0,0,.24);
      border-radius: 10px;
      color: var(--text);
      text-align: left;
      padding: 9px 10px;
      cursor: pointer;
      font-size: 12px;
    }

    .suggestBtn strong {
      display: block;
      font-size: 13px;
    }

    .suggestBtn span {
      display: block;
      margin-top: 2px;
      color: var(--muted);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    @media (max-width: 700px) {
      .topMenu { grid-template-columns: 1fr; }
      .search { min-width: 100%; }
      .tile { min-height: 92px; }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="panel">
      <header>
        <div class="headTop">
          <div class="brand">
            <strong>StreamDeck Remote</strong>
            <span>Touch Launcher mit Profilen, Unterseiten und zentraler Programmlogik</span>
          </div>

          <div class="headActions">
            <div class="chip" title="API Status">
              <span class="dot" id="dotApi"></span>
              <span id="apiState">offline</span>
            </div>
            <div class="chip" title="WoW Prozess">
              <span class="dot" id="dotWow"></span>
              <span id="wowState">stopped</span>
            </div>

            <button class="btn primary" id="btnAdd" type="button">+ Tile</button>
            <button class="btn" id="btnSettings" type="button">Einstellungen</button>
          </div>
        </div>

        <div class="toolbar">
          <div class="topMenu">
            <div class="search">
              <span>Suche</span>
              <input id="q" type="search" placeholder="Filter: wow, logs, code..." autocomplete="off" />
              <button class="btn" id="clearQ" type="button">Clear</button>
            </div>
            <div class="quickProgram">
              <input id="quickProgramInput" type="search" placeholder="Programmname oder Pfad (z.B. obs, chrome, C:\\Tools\\app.exe)" autocomplete="off" />
              <button class="btn primary" id="quickProgramAdd" type="button">Programm als Tile</button>
            </div>
          </div>
          <div class="tabs" id="profileTabs"></div>
          <div class="tabs" id="pageTabs"></div>
        </div>
      </header>

      <main class="content">
        <section class="section" id="recentSection" hidden>
          <h2>Zuletzt benutzt <span style="font-size:12px; opacity:.75">Long-Press fuer Tile-Menue</span></h2>
          <div class="grid" id="recentGrid"></div>
        </section>

        <section class="section">
          <h2 id="sectionTitle">Tiles</h2>
          <div class="grid" id="grid"></div>
          <div class="empty" id="empty" hidden>Keine Tiles fuer diese Auswahl.</div>
        </section>
      </main>
    </div>
  </div>

  <div class="toast" id="toast" aria-live="polite"></div>

  <dialog id="dlgAdd">
    <div class="dlgTitle" id="addDialogTitle">Tile hinzufuegen</div>
    <div class="dlgHint" id="addDialogHint">Programm/Link/Ordner auswaehlen, speichern, fertig. Die App validiert Pfade automatisch.</div>

    <div class="row">
      <select id="addType">
        <option value="app">Programm (empfohlen)</option>
        <option value="url">Webseite (http/https)</option>
        <option value="folder">Ordner</option>
        <option value="protocol">Protokoll-Link (z.B. discord://)</option>
        <option value="action">Spezialaktion (advanced)</option>
      </select>
      <select id="addProfile"></select>
      <select id="addPage"></select>
    </div>

    <div class="row">
      <input id="addLabel" placeholder="Titel" maxlength="40" />
      <input id="addSubtitle" placeholder="Untertitel (optional)" maxlength="80" />
    </div>

    <div class="row" id="rowTarget">
      <input id="addTarget" placeholder="Ziel: URL oder Pfad" />
      <button class="btn" id="addBrowse" type="button">Browse</button>
    </div>
    <div class="row" id="rowProgramTools">
      <button class="btn" id="addFindProgram" type="button">Programm automatisch finden</button>
      <button class="btn" id="addTopPrograms" type="button">Installierte Apps anzeigen</button>
    </div>
    <div class="row" id="rowProgramHints" hidden>
      <div class="hint">Treffer aus deinem System (Pfad geprueft)</div>
      <div class="suggestGrid" id="addProgramHints"></div>
    </div>

    <div class="row" id="rowAction" hidden>
      <select id="addAction">
        <option value="terminal">terminal</option>
        <option value="powershell">powershell</option>
        <option value="browser">browser</option>
        <option value="discord">discord</option>
        <option value="wowStart">wowStart</option>
        <option value="openWorkspace">openWorkspace</option>
      </select>
    </div>

    <div class="row" id="rowArgs" hidden>
      <input id="addArgs" placeholder="Args (optional, getrennt mit Leerzeichen)" />
      <input id="addStartIn" placeholder="Startordner (optional)" />
    </div>

    <div class="row">
      <select id="addIconMode">
        <option value="auto">Icon: Auto (bei Programmen)</option>
        <option value="emoji">Icon: Emoji</option>
        <option value="image">Icon: Bilddatei</option>
      </select>
      <input id="addIconEmoji" placeholder="Emoji, z.B. 🚀" maxlength="4" />
      <input id="addIconFile" type="file" accept="image/*" />
    </div>

    <div class="rowActions">
      <button class="btn" id="addCancel" type="button">Abbrechen</button>
      <button class="btn primary" id="addSave" type="button">Speichern</button>
    </div>
  </dialog>
  <dialog id="dlgTile">
    <div class="dlgTitle" id="tileMenuTitle">Tile</div>
    <div class="dlgHint">Built-ins koennen ausgeblendet werden, Custom Tiles koennen bearbeitet oder geloescht werden.</div>

    <div class="row">
      <button class="btn" id="tileFav" type="button">Favorit</button>
      <button class="btn" id="tileEdit" type="button">Bearbeiten</button>
      <button class="btn warn" id="tileHide" type="button">Ausblenden</button>
      <button class="btn danger" id="tileDelete" type="button">Loeschen</button>
    </div>

    <div class="rowActions">
      <button class="btn" id="tileClose" type="button">Schliessen</button>
    </div>
  </dialog>

  <dialog id="dlgSettings">
    <div class="dlgTitle">Einstellungen</div>
    <div class="dlgHint">Token lokal speichern, Launcher automatisch erkennen oder direkt per Dateidialog setzen.</div>

    <div class="row">
      <input id="tokenInput" placeholder="Token" />
      <button class="btn primary" id="saveToken" type="button">Token speichern</button>
      <button class="btn" id="testToken" type="button">Token testen</button>
      <button class="btn" id="refreshAll" type="button">Neu laden</button>
    </div>

    <div class="setGroup">
      <div class="dlgTitle" style="font-size: 14px;">Launcher Pfade</div>
      <div class="setButtons">
        <button class="btn" id="autoDetectAll" type="button">Alle automatisch erkennen</button>
      </div>
      <div id="launchersBox"></div>
    </div>

    <div class="setGroup">
      <div class="dlgTitle" style="font-size: 14px;">WoW Ordner + Prozess</div>
      <div id="wowBox"></div>
    </div>

    <div class="setGroup">
      <div class="dlgTitle" style="font-size: 14px;">Ausgeblendete Tiles</div>
      <div id="hiddenBox"></div>
    </div>

    <div class="setGroup">
      <div class="dlgTitle" style="font-size: 14px;">Server Logs</div>
      <div class="setButtons">
        <button class="btn" id="logsRefresh" type="button">Logs laden</button>
        <button class="btn" id="logsCopy" type="button">Logs kopieren</button>
      </div>
      <div class="row">
        <select id="logLines">
          <option value="100">100 Zeilen</option>
          <option value="200" selected>200 Zeilen</option>
          <option value="500">500 Zeilen</option>
          <option value="1000">1000 Zeilen</option>
        </select>
        <select id="logEnabled">
          <option value="true">Datei-Logging: aktiv</option>
          <option value="false">Datei-Logging: aus</option>
        </select>
        <select id="logLevel">
          <option value="ERROR">Level: ERROR</option>
          <option value="WARN">Level: WARN</option>
          <option value="INFO" selected>Level: INFO</option>
          <option value="DEBUG">Level: DEBUG</option>
        </select>
        <input id="logMaxFiles" type="number" min="3" max="90" step="1" placeholder="max Dateien (3-90)" />
      </div>
      <div class="row">
        <input id="logDir" placeholder="Log-Ordner (optional, leer = Standard)" />
        <button class="btn primary" id="logSave" type="button">Logging speichern</button>
      </div>
      <div class="logMeta" id="logMeta">Logs nicht geladen.</div>
      <pre class="logView" id="logView"></pre>
    </div>

    <div class="rowActions">
      <button class="btn" id="settingsClose" type="button">Schliessen</button>
    </div>
  </dialog>

  <script>
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker
        .register("/sw.js", { updateViaCache: "none" })
        .then((reg) => reg.update().catch(() => {}))
        .catch(() => {});
    }

    const CLIENT_BUILD = "2026-02-22.4";
    const LS = {
      token: "sd_token",
      profile: "sd_profile",
      page: "sd_page",
      fav: "sd_fav",
      recent: "sd_recent",
      hidden: "sd_hidden"
    };

    function loadStoredArray(key, maxItems = 100) {
      try {
        const raw = localStorage.getItem(key);
        const parsed = raw ? JSON.parse(raw) : [];
        if (!Array.isArray(parsed)) return [];
        return parsed
          .filter((x) => typeof x === "string")
          .map((x) => x.trim())
          .filter(Boolean)
          .slice(0, maxItems);
      } catch {
        return [];
      }
    }

    const state = {
      token: localStorage.getItem(LS.token) || "",
      profile: localStorage.getItem(LS.profile) || "",
      page: localStorage.getItem(LS.page) || "",
      favorites: new Set(loadStoredArray(LS.fav, 200)),
      recent: loadStoredArray(LS.recent, 50),
      hidden: new Set(loadStoredArray(LS.hidden, 200)),
      profiles: [],
      tiles: [],
      wowRunning: null,
      longPressTimer: null,
      longPressTileId: "",
      toastTimer: null,
      pollTimer: null,
      bootstrapTick: 0,
      addProgramSearchTimer: null,
      editingTileId: "",
      editingTileIconData: "",
      serverVersion: "",
      serverBuild: "",
      serverFeatures: {},
      legacyServerHintShown: false
    };

    const el = {
      profileTabs: document.getElementById("profileTabs"),
      pageTabs: document.getElementById("pageTabs"),
      q: document.getElementById("q"),
      clearQ: document.getElementById("clearQ"),
      sectionTitle: document.getElementById("sectionTitle"),
      grid: document.getElementById("grid"),
      empty: document.getElementById("empty"),
      recentSection: document.getElementById("recentSection"),
      recentGrid: document.getElementById("recentGrid"),

      apiState: document.getElementById("apiState"),
      dotApi: document.getElementById("dotApi"),
      wowState: document.getElementById("wowState"),
      dotWow: document.getElementById("dotWow"),

      btnAdd: document.getElementById("btnAdd"),
      btnSettings: document.getElementById("btnSettings"),
      quickProgramInput: document.getElementById("quickProgramInput"),
      quickProgramAdd: document.getElementById("quickProgramAdd"),

      toast: document.getElementById("toast"),

      dlgAdd: document.getElementById("dlgAdd"),
      addDialogTitle: document.getElementById("addDialogTitle"),
      addDialogHint: document.getElementById("addDialogHint"),
      addType: document.getElementById("addType"),
      addProfile: document.getElementById("addProfile"),
      addPage: document.getElementById("addPage"),
      addLabel: document.getElementById("addLabel"),
      addSubtitle: document.getElementById("addSubtitle"),
      addTarget: document.getElementById("addTarget"),
      addBrowse: document.getElementById("addBrowse"),
      rowTarget: document.getElementById("rowTarget"),
      rowProgramTools: document.getElementById("rowProgramTools"),
      addFindProgram: document.getElementById("addFindProgram"),
      addTopPrograms: document.getElementById("addTopPrograms"),
      rowProgramHints: document.getElementById("rowProgramHints"),
      addProgramHints: document.getElementById("addProgramHints"),
      rowAction: document.getElementById("rowAction"),
      addAction: document.getElementById("addAction"),
      rowArgs: document.getElementById("rowArgs"),
      addArgs: document.getElementById("addArgs"),
      addStartIn: document.getElementById("addStartIn"),
      addIconMode: document.getElementById("addIconMode"),
      addIconEmoji: document.getElementById("addIconEmoji"),
      addIconFile: document.getElementById("addIconFile"),
      addCancel: document.getElementById("addCancel"),
      addSave: document.getElementById("addSave"),

      dlgTile: document.getElementById("dlgTile"),
      tileMenuTitle: document.getElementById("tileMenuTitle"),
      tileFav: document.getElementById("tileFav"),
      tileEdit: document.getElementById("tileEdit"),
      tileHide: document.getElementById("tileHide"),
      tileDelete: document.getElementById("tileDelete"),
      tileClose: document.getElementById("tileClose"),

      dlgSettings: document.getElementById("dlgSettings"),
      tokenInput: document.getElementById("tokenInput"),
      saveToken: document.getElementById("saveToken"),
      testToken: document.getElementById("testToken"),
      refreshAll: document.getElementById("refreshAll"),
      autoDetectAll: document.getElementById("autoDetectAll"),
      launchersBox: document.getElementById("launchersBox"),
      wowBox: document.getElementById("wowBox"),
      hiddenBox: document.getElementById("hiddenBox"),
      logsRefresh: document.getElementById("logsRefresh"),
      logsCopy: document.getElementById("logsCopy"),
      logLines: document.getElementById("logLines"),
      logEnabled: document.getElementById("logEnabled"),
      logLevel: document.getElementById("logLevel"),
      logMaxFiles: document.getElementById("logMaxFiles"),
      logDir: document.getElementById("logDir"),
      logSave: document.getElementById("logSave"),
      logMeta: document.getElementById("logMeta"),
      logView: document.getElementById("logView"),
      settingsClose: document.getElementById("settingsClose")
    };

    function saveSet(key, setValue) {
      localStorage.setItem(key, JSON.stringify(Array.from(setValue)));
    }

    function showToast(message) {
      if (state.toastTimer) clearTimeout(state.toastTimer);
      el.toast.textContent = message;
      el.toast.className = "toast show";
      state.toastTimer = setTimeout(() => {
        el.toast.className = "toast";
      }, 2200);
    }

    function showLegacyServerHint(missingEndpoint) {
      if (state.legacyServerHintShown) return;
      state.legacyServerHintShown = true;
      showToast(`Server-Update noetig: ${missingEndpoint} fehlt. Bitte laufenden StreamDeck-Server neu starten.`);
    }

    function setApiState(text, statusClass) {
      el.apiState.textContent = text;
      el.dotApi.className = `dot ${statusClass || ""}`.trim();
    }

    function setWowState(text, statusClass) {
      el.wowState.textContent = text;
      el.dotWow.className = `dot ${statusClass || ""}`.trim();
    }

    async function api(path, opts = {}) {
      if (!state.token) throw new Error("Token fehlt");
      const method = opts.method || "GET";
      const headers = { "X-Token": state.token };
      if (opts.body) headers["Content-Type"] = "application/json";
      const response = await fetch(path, {
        method,
        headers,
        body: opts.body ? JSON.stringify(opts.body) : undefined
      });

      const data = await response.json().catch(() => null);
      const reqId = response.headers.get("x-request-id") || "";
      if (!response.ok) {
        const base = (data && data.error) ? data.error : `HTTP ${response.status}`;
        throw new Error(reqId ? `${base} (req ${reqId})` : base);
      }
      return data;
    }

    function profileById(id) {
      return state.profiles.find((p) => p.id === id) || null;
    }

    function pagesForProfile(profileId) {
      const p = profileById(profileId);
      if (!p || !Array.isArray(p.pages) || !p.pages.length) return [{ id: "main", label: "Main" }];
      return p.pages;
    }

    function parseArgs(text) {
      const raw = String(text || "").trim();
      if (!raw) return [];
      const out = [];
      const re = /"([^"]*)"|'([^']*)'|(\S+)/g;
      let m = null;
      while ((m = re.exec(raw)) !== null) {
        out.push(m[1] || m[2] || m[3] || "");
      }
      return out.filter(Boolean);
    }

    function formatArgs(args) {
      const list = Array.isArray(args) ? args : [];
      return list.map((x) => (/\s/.test(String(x)) ? `"${String(x)}"` : String(x))).join(" ").trim();
    }

    function escapeCssValue(value) {
      const raw = String(value || "");
      if (window.CSS && typeof window.CSS.escape === "function") return window.CSS.escape(raw);
      return raw.replace(/["\\]/g, "\\$&");
    }

    function preferredProfileId() {
      if (state.profile && state.profile !== "fav") return state.profile;
      return state.profiles.find((p) => p.id !== "fav")?.id || state.profiles[0]?.id || "work";
    }

    function preferredPageId(profileId) {
      const pages = pagesForProfile(profileId);
      if (state.page && pages.some((p) => p.id === state.page)) return state.page;
      return pages[0]?.id || "main";
    }

    function inferProgramLabel(rawPath) {
      const value = String(rawPath || "").trim();
      if (!value) return "";
      const base = value.split(/[\\/]/).pop() || value;
      return base.replace(/\.[^/.]+$/, "").replace(/[-_]+/g, " ").trim();
    }

    function unquoteInput(value) {
      const text = String(value || "").trim();
      if ((text.startsWith("\"") && text.endsWith("\"")) || (text.startsWith("'") && text.endsWith("'"))) {
        return text.slice(1, -1).trim();
      }
      return text;
    }

    function looksLikePathInput(value) {
      const text = unquoteInput(value);
      return /^[a-z]:[\\/]/i.test(text) || text.includes("\\") || text.includes("/") || text.startsWith(".\\");
    }

    function splitAppTargetInput(rawInput) {
      const raw = String(rawInput || "").trim();
      if (!raw) return { target: "", inlineArgs: [] };

      const pathWithArgs = raw.match(/^(.+\.(?:exe|lnk|bat|cmd|com))(?:\s+(.+))?$/i);
      if (pathWithArgs) {
        return {
          target: unquoteInput(pathWithArgs[1]),
          inlineArgs: parseArgs(pathWithArgs[2] || "")
        };
      }

      const tokens = parseArgs(raw);
      if (tokens.length > 1 && looksLikePathInput(tokens[0])) {
        return {
          target: unquoteInput(tokens[0]),
          inlineArgs: tokens.slice(1)
        };
      }

      return { target: unquoteInput(raw), inlineArgs: [] };
    }

    function isHttp404Error(error) {
      return /HTTP 404/i.test(String(error?.message || error || ""));
    }

    async function fetchPrograms(query = "", limit = 16) {
      const q = encodeURIComponent(String(query || "").trim());
      const l = Math.max(1, Math.min(50, Number(limit) || 16));
      const data = await api(`/api/programs?q=${q}&limit=${l}`);
      return Array.isArray(data.programs) ? data.programs : [];
    }

    async function resolveProgramInput(input, options = {}) {
      const allowDirectPathFallback = Boolean(options.allowDirectPathFallback);
      try {
        const data = await api("/api/programs/resolve", { method: "POST", body: { input } });
        if (!data || !data.path) throw new Error("Programm nicht gefunden");
        return String(data.path);
      } catch (error) {
        if (allowDirectPathFallback && looksLikePathInput(input)) {
          return unquoteInput(input);
        }
        if (isHttp404Error(error)) {
          showLegacyServerHint("/api/programs/resolve");
          throw new Error("Programmsuche-Endpunkt fehlt auf dem laufenden Server. Bitte Server neu starten.");
        }
        throw error;
      }
    }

    async function fetchTileDetails(id) {
      if (!id) throw new Error("Tile-ID fehlt");
      if (!state.serverFeatures || state.serverFeatures.tileDetails !== true) {
        showLegacyServerHint("/api/tiles/:id");
        throw new Error("Tile-Details-Endpunkt fehlt auf dem laufenden Server. Bitte Server neu starten.");
      }
      try {
        const data = await api(`/api/tiles/${encodeURIComponent(id)}`);
        if (!data || !data.tile) throw new Error("Tile konnte nicht geladen werden");
        return data.tile;
      } catch (error) {
        if (isHttp404Error(error)) {
          showLegacyServerHint("/api/tiles/:id");
          throw new Error("Tile-Details-Endpunkt fehlt auf dem laufenden Server. Bitte Server neu starten.");
        }
        throw error;
      }
    }

    function useProgramSuggestion(program) {
      if (!program || !program.path) return;
      el.addTarget.value = program.path;
      if (!el.addLabel.value.trim()) el.addLabel.value = program.label || inferProgramLabel(program.path);
      if (!el.addSubtitle.value.trim()) {
        const sourceLabel = program.source ? `Auto: ${program.source}` : "Auto gefunden";
        el.addSubtitle.value = sourceLabel;
      }
      if (el.addIconMode.value === "emoji") {
        el.addIconMode.value = "auto";
        updateAddFormVisibility();
      }
      showToast(`Programm gewaehlt: ${program.label || inferProgramLabel(program.path)}`);
    }

    function renderProgramSuggestions(programs = []) {
      el.addProgramHints.textContent = "";
      if (!Array.isArray(programs) || !programs.length) {
        el.rowProgramHints.hidden = true;
        return;
      }
      el.rowProgramHints.hidden = false;
      for (const program of programs) {
        const btn = document.createElement("button");
        btn.className = "suggestBtn";
        btn.type = "button";
        const title = document.createElement("strong");
        title.textContent = program.label || inferProgramLabel(program.path);
        const sub = document.createElement("span");
        sub.textContent = program.path || "";
        btn.appendChild(title);
        btn.appendChild(sub);
        btn.addEventListener("click", () => useProgramSuggestion(program));
        el.addProgramHints.appendChild(btn);
      }
    }

    async function quickAddProgram(input) {
      if (!state.token) throw new Error("Bitte zuerst Token setzen");
      const query = String(input || "").trim();
      if (!query) throw new Error("Bitte Programmname oder Pfad eingeben");
      const splitInput = splitAppTargetInput(query);
      const targetInput = splitInput.target || query;

      let resolvedPath = "";
      try {
        resolvedPath = await resolveProgramInput(targetInput, { allowDirectPathFallback: true });
      } catch (error) {
        if (looksLikePathInput(targetInput)) {
          resolvedPath = unquoteInput(targetInput);
        } else {
          throw error;
        }
      }
      const profile = preferredProfileId();
      const page = preferredPageId(profile);
      const label = inferProgramLabel(resolvedPath);

      const tile = {
        profile,
        page,
        type: "app",
        label: label || "Programm",
        subtitle: "Auto hinzugefuegt",
        target: resolvedPath,
        iconMode: "auto"
      };
      if (splitInput.inlineArgs.length) tile.args = splitInput.inlineArgs;

      await api("/api/tiles/upsert", { method: "POST", body: { tile } });
      await loadBootstrap();
      showToast(`Programm-Tile erstellt: ${tile.label}`);
    }

    function renderSettingsNeedToken() {
      const msg = "Token fehlt. Bitte Token speichern, dann werden Einstellungen und Logs geladen.";
      el.launchersBox.textContent = "";
      el.wowBox.textContent = "";
      el.hiddenBox.textContent = "";

      const node1 = document.createElement("div");
      node1.className = "setLabel";
      node1.textContent = msg;
      const node2 = document.createElement("div");
      node2.className = "setLabel";
      node2.textContent = msg;
      const node3 = document.createElement("div");
      node3.className = "setLabel";
      node3.textContent = msg;
      el.launchersBox.appendChild(node1);
      el.wowBox.appendChild(node2);
      el.hiddenBox.appendChild(node3);

      el.logMeta.textContent = msg;
      el.logView.textContent = "";
      el.logEnabled.value = "true";
      el.logLevel.value = "INFO";
      el.logMaxFiles.value = "14";
      el.logDir.value = "";
      el.logsRefresh.disabled = true;
      el.logsCopy.disabled = true;
      el.logSave.disabled = true;
      el.logEnabled.disabled = true;
      el.logLevel.disabled = true;
      el.logMaxFiles.disabled = true;
      el.logDir.disabled = true;
      el.logLines.disabled = true;
    }

    function setLoggingUi(logging) {
      const enabled = logging?.enabled !== false;
      el.logEnabled.value = enabled ? "true" : "false";
      el.logLevel.value = String(logging?.effectiveLevel || logging?.level || "INFO").toUpperCase();
      el.logMaxFiles.value = String(logging?.maxFiles || 14);
      el.logDir.value = String(logging?.dir || "");
      el.logsRefresh.disabled = false;
      el.logsCopy.disabled = false;
      el.logSave.disabled = false;
      el.logEnabled.disabled = false;
      el.logLevel.disabled = false;
      el.logMaxFiles.disabled = false;
      el.logDir.disabled = false;
      el.logLines.disabled = false;
    }

    async function loadRecentLogs() {
      const lines = Math.max(10, Math.min(2000, Number(el.logLines.value) || 200));
      let data = null;
      try {
        data = await api(`/api/logs/recent?lines=${lines}`);
      } catch (error) {
        if (isHttp404Error(error)) {
          showLegacyServerHint("/api/logs/recent");
          throw new Error("Log-Endpunkt fehlt auf dem laufenden Server. Bitte Server neu starten.");
        }
        throw error;
      }
      const logLines = Array.isArray(data.lines) ? data.lines : [];
      el.logView.textContent = logLines.join("\n");
      el.logMeta.textContent = `Zeilen: ${logLines.length} | Ordner: ${data.logDir || "-"} | Logging: ${data.loggingEnabled ? "aktiv" : "aus"} | Level: ${data.loggingLevel || "-"}`;
    }

    function tileIconNode(tile) {
      const wrap = document.createElement("div");
      wrap.className = "iconWrap";

      if (tile.iconData) {
        const img = document.createElement("img");
        img.src = tile.iconData;
        img.alt = "";
        wrap.appendChild(img);
        return wrap;
      }

      wrap.textContent = tile.icon || "■";
      return wrap;
    }

    function applySearchFilter(tile, q) {
      if (!q) return true;
      const needle = q.toLowerCase();
      return [tile.label, tile.subtitle, tile.type]
        .filter(Boolean)
        .some((v) => String(v).toLowerCase().includes(needle));
    }

    function allVisibleTiles() {
      return state.tiles.filter((t) => !state.hidden.has(t.id));
    }

    function currentTiles() {
      const q = el.q.value.trim();
      const tiles = allVisibleTiles().filter((t) => applySearchFilter(t, q));
      if (state.profile === "fav") {
        return tiles.filter((t) => state.favorites.has(t.id));
      }
      return tiles.filter((t) => t.profile === state.profile && (t.page || "main") === state.page);
    }

    function renderProfileTabs() {
      el.profileTabs.textContent = "";
      for (const p of state.profiles) {
        const btn = document.createElement("button");
        btn.className = "tab";
        btn.type = "button";
        btn.dataset.profile = p.id;
        btn.setAttribute("aria-selected", String(p.id === state.profile));
        btn.textContent = p.label;
        el.profileTabs.appendChild(btn);
      }
    }

    function renderPageTabs() {
      el.pageTabs.textContent = "";
      const pages = pagesForProfile(state.profile);
      for (const page of pages) {
        const btn = document.createElement("button");
        btn.className = "tab";
        btn.type = "button";
        btn.dataset.page = page.id;
        btn.setAttribute("aria-selected", String(page.id === state.page));
        btn.textContent = page.label;
        el.pageTabs.appendChild(btn);
      }
    }
    function renderTiles() {
      renderProfileTabs();
      renderPageTabs();

      const profileLabel = profileById(state.profile)?.label || "Tiles";
      const pageLabel = pagesForProfile(state.profile).find((p) => p.id === state.page)?.label || "Main";
      el.sectionTitle.textContent = `${profileLabel} / ${pageLabel}`;

      const tiles = currentTiles();
      el.grid.textContent = "";

      for (const tile of tiles) {
        const btn = document.createElement("button");
        btn.className = "tile";
        btn.type = "button";
        btn.dataset.id = tile.id;
        btn.setAttribute("aria-label", tile.subtitle ? `${tile.label}, ${tile.subtitle}` : tile.label);

        btn.appendChild(tileIconNode(tile));

        const meta = document.createElement("div");
        meta.className = "meta";
        const title = document.createElement("strong");
        title.textContent = tile.label;
        const sub = document.createElement("span");
        sub.textContent = tile.subtitle || tile.type;
        meta.appendChild(title);
        meta.appendChild(sub);
        btn.appendChild(meta);

        if (state.favorites.has(tile.id)) {
          const fav = document.createElement("div");
          fav.className = "fav";
          fav.textContent = "Fav";
          btn.appendChild(fav);
        }

        el.grid.appendChild(btn);
      }

      el.empty.hidden = tiles.length > 0;

      el.recentGrid.textContent = "";
      const map = new Map(allVisibleTiles().map((t) => [t.id, t]));
      const recentTiles = state.recent.map((id) => map.get(id)).filter(Boolean).slice(0, 6);
      if (el.q.value.trim() || !recentTiles.length) {
        el.recentSection.hidden = true;
      } else {
        el.recentSection.hidden = false;
        for (const tile of recentTiles) {
          const node = document.createElement("button");
          node.className = "tile";
          node.type = "button";
          node.dataset.id = tile.id;
          node.setAttribute("aria-label", tile.subtitle ? `${tile.label}, ${tile.subtitle}` : tile.label);
          node.appendChild(tileIconNode(tile));

          const m = document.createElement("div");
          m.className = "meta";
          const t = document.createElement("strong");
          t.textContent = tile.label;
          const s = document.createElement("span");
          s.textContent = tile.subtitle || tile.type;
          m.appendChild(t);
          m.appendChild(s);
          node.appendChild(m);

          el.recentGrid.appendChild(node);
        }
      }
    }

    async function loadBootstrap() {
      const data = await api("/api/bootstrap");
      state.profiles = Array.isArray(data.profiles) ? data.profiles : [];
      state.tiles = Array.isArray(data.tiles) ? data.tiles : [];
      state.wowRunning = Boolean(data.wowRunning);
      state.serverVersion = String(data.serverVersion || state.serverVersion || "");
      state.serverBuild = String(data.serverBuild || state.serverBuild || "");
      state.serverFeatures = data.features && typeof data.features === "object" ? data.features : state.serverFeatures;

      if (!state.profile || !profileById(state.profile)) {
        state.profile = state.profiles[0]?.id || "work";
      }

      const pages = pagesForProfile(state.profile);
      if (!state.page || !pages.some((p) => p.id === state.page)) {
        state.page = pages[0]?.id || "main";
      }

      localStorage.setItem(LS.profile, state.profile);
      localStorage.setItem(LS.page, state.page);
      renderTiles();
    }

    async function pollStatus() {
      try {
        const health = await api("/api/health");
        state.serverVersion = String(health?.version || state.serverVersion || "");
        state.serverBuild = String(health?.build || state.serverBuild || "");
        state.serverFeatures = health?.features && typeof health.features === "object"
          ? health.features
          : state.serverFeatures;

        const suffix = state.serverVersion ? ` v${state.serverVersion}` : "";
        setApiState(`online${suffix}`, "ok");
        if (!health?.features || health.features.logsRecent !== true || health.features.programResolve !== true) {
          showLegacyServerHint("neue API-Features");
        }
      } catch (error) {
        setApiState(state.token ? "offline" : "token?", state.token ? "err" : "");
      }

      try {
        const st = await api("/api/status");
        state.wowRunning = Boolean(st.wowRunning);
        setWowState(state.wowRunning ? "running" : "stopped", state.wowRunning ? "ok" : "");
      } catch {
        state.wowRunning = null;
        setWowState("unknown", "err");
      }
    }

    function pushRecent(id) {
      state.recent = [id, ...state.recent.filter((x) => x !== id)].slice(0, 12);
      localStorage.setItem(LS.recent, JSON.stringify(state.recent));
    }

    async function runTile(id) {
      const tile = state.tiles.find((x) => x.id === id);
      if (!tile) return;

      const target = document.querySelector(`button.tile[data-id="${escapeCssValue(id)}"]`);
      if (target) target.disabled = true;

      try {
        await api("/api/run", { method: "POST", body: { tileId: id } });
        pushRecent(id);
        setApiState("ok", "ok");
        showToast(`Ausgefuehrt: ${tile.label}`);
      } catch (error) {
        setApiState("fehler", "err");
        showToast(`Fehler: ${error.message || String(error)}`);
      } finally {
        if (target) target.disabled = false;
        renderTiles();
      }
    }

    function openTileMenu(tile) {
      el.tileMenuTitle.textContent = tile.label;
      el.tileFav.textContent = state.favorites.has(tile.id) ? "Favorit entfernen" : "Als Favorit";
      el.tileEdit.style.display = tile.builtin ? "none" : "";
      el.tileDelete.style.display = tile.builtin ? "none" : "";
      el.tileHide.style.display = "";
      if (!el.dlgTile.open) el.dlgTile.showModal();

      el.tileFav.onclick = () => {
        if (state.favorites.has(tile.id)) state.favorites.delete(tile.id);
        else state.favorites.add(tile.id);
        saveSet(LS.fav, state.favorites);
        renderTiles();
        el.dlgTile.close();
      };

      el.tileHide.onclick = () => {
        state.hidden.add(tile.id);
        saveSet(LS.hidden, state.hidden);
        renderTiles();
        el.dlgTile.close();
      };

      el.tileEdit.onclick = async () => {
        if (tile.builtin) return;
        el.dlgTile.close();
        try {
          await openAddDialog(tile);
        } catch (error) {
          showToast(`Bearbeiten fehlgeschlagen: ${error.message || String(error)}`);
        }
      };

      el.tileDelete.onclick = async () => {
        if (tile.builtin) return;
        try {
          await api("/api/tiles/delete", { method: "POST", body: { id: tile.id } });
          state.favorites.delete(tile.id);
          state.hidden.delete(tile.id);
          saveSet(LS.fav, state.favorites);
          saveSet(LS.hidden, state.hidden);
          await loadBootstrap();
          showToast("Tile geloescht");
        } catch (error) {
          showToast(`Loeschen fehlgeschlagen: ${error.message || String(error)}`);
        } finally {
          el.dlgTile.close();
        }
      };

      el.tileClose.onclick = () => el.dlgTile.close();
    }

    function openTileMenuById(tileId) {
      const tile = state.tiles.find((x) => x.id === tileId);
      if (tile) openTileMenu(tile);
    }

    function fillProfileSelect(selectEl, selectedId) {
      selectEl.textContent = "";
      for (const p of state.profiles) {
        if (p.id === "fav") continue;
        const opt = document.createElement("option");
        opt.value = p.id;
        opt.textContent = p.label;
        selectEl.appendChild(opt);
      }
      if (selectedId && Array.from(selectEl.options).some((o) => o.value === selectedId)) {
        selectEl.value = selectedId;
      }
    }

    function fillPageSelect(profileId, pageSelect, selectedId = "") {
      pageSelect.textContent = "";
      const pages = pagesForProfile(profileId);
      for (const page of pages) {
        const opt = document.createElement("option");
        opt.value = page.id;
        opt.textContent = page.label;
        pageSelect.appendChild(opt);
      }
      if (selectedId && Array.from(pageSelect.options).some((o) => o.value === selectedId)) {
        pageSelect.value = selectedId;
      }
    }

    function updateAddFormVisibility() {
      const type = el.addType.value;
      el.rowAction.hidden = type !== "action";
      el.rowTarget.hidden = type === "action";
      el.rowArgs.hidden = type !== "app";
      el.rowProgramTools.hidden = type !== "app";
      if (type !== "app") el.rowProgramHints.hidden = true;

      if (type === "app") el.addTarget.placeholder = "Programmname oder Pfad (z.B. obs, chrome, C:\\Apps\\tool.exe)";
      else if (type === "url") el.addTarget.placeholder = "https://...";
      else if (type === "folder") el.addTarget.placeholder = "Ordnerpfad";
      else if (type === "protocol") el.addTarget.placeholder = "protocol://...";
      else el.addTarget.placeholder = "Ziel";

      const iconMode = el.addIconMode.value;
      el.addIconEmoji.style.display = iconMode === "emoji" ? "" : "none";
      el.addIconFile.style.display = iconMode === "image" ? "" : "none";

      const browseKind = type === "folder" ? "folder" : "file";
      el.addBrowse.dataset.kind = browseKind;
      el.addBrowse.style.display = (type === "app" || type === "folder") ? "" : "none";
    }

    async function readImageDataUrl(file) {
      if (!file) return "";
      if (file.size > 2 * 1024 * 1024) {
        throw new Error("Bild zu gross (max 2 MB)");
      }
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(String(reader.result || ""));
        reader.onerror = () => reject(new Error("Bild konnte nicht gelesen werden"));
        reader.readAsDataURL(file);
      });
    }

    function setAddDialogMode(editing) {
      if (editing) {
        el.addDialogTitle.textContent = "Tile bearbeiten";
        el.addDialogHint.textContent = "Du aktualisierst ein bestehendes Custom Tile. Built-in Tiles bleiben unveraendert.";
        el.addSave.textContent = "Aenderungen speichern";
      } else {
        el.addDialogTitle.textContent = "Tile hinzufuegen";
        el.addDialogHint.textContent = "Programm/Link/Ordner auswaehlen, speichern, fertig. Die App validiert Pfade automatisch.";
        el.addSave.textContent = "Speichern";
      }
    }

    function resetAddDialogForm(profileId, pageId) {
      const profile = profileId || preferredProfileId();
      fillProfileSelect(el.addProfile, profile);
      fillPageSelect(el.addProfile.value || profile, el.addPage, pageId || state.page || "main");

      el.addType.value = "app";
      el.addLabel.value = "";
      el.addSubtitle.value = "";
      el.addTarget.value = "";
      el.addAction.value = "terminal";
      el.addArgs.value = "";
      el.addStartIn.value = "";
      el.addIconMode.value = "auto";
      el.addIconEmoji.value = "";
      el.addIconFile.value = "";
      el.addProgramHints.textContent = "";
      el.rowProgramHints.hidden = true;
      state.editingTileId = "";
      state.editingTileIconData = "";
      setAddDialogMode(false);
    }

    async function openAddDialog(editTile = null) {
      const profile = preferredProfileId();
      resetAddDialogForm(profile, state.page || "main");

      if (editTile && editTile.id) {
        const details = await fetchTileDetails(editTile.id);
        if (details.builtin) throw new Error("Built-in Tiles koennen nicht bearbeitet werden");

        state.editingTileId = details.id;
        state.editingTileIconData = details.iconMode === "image" ? String(details.iconData || "") : "";
        setAddDialogMode(true);

        fillProfileSelect(el.addProfile, details.profile || profile);
        fillPageSelect(el.addProfile.value || details.profile || profile, el.addPage, details.page || "main");

        el.addType.value = details.type || "app";
        el.addLabel.value = details.label || "";
        el.addSubtitle.value = details.subtitle || "";
        el.addTarget.value = details.target || "";
        el.addAction.value = details.action || "terminal";
        el.addArgs.value = formatArgs(details.args || []);
        el.addStartIn.value = details.startIn || "";
        el.addIconMode.value = details.iconMode || "emoji";
        el.addIconEmoji.value = details.iconMode === "emoji" ? (details.icon || "") : "";
      }

      updateAddFormVisibility();
      el.dlgAdd.showModal();

      try {
        const suggested = await fetchPrograms(el.addType.value === "app" ? el.addTarget.value : "", 10);
        renderProgramSuggestions(suggested);
      } catch {
        el.rowProgramHints.hidden = true;
      }
    }
    async function refreshSettingsContent() {
      if (!state.token) {
        renderSettingsNeedToken();
        return;
      }

      try {
        const settings = await api("/api/settings");

        el.launchersBox.textContent = "";
        for (const launcher of settings.launchers || []) {
          const row = document.createElement("div");
          row.className = "setRow";

          const label = document.createElement("div");
          label.className = "setLabel";
          label.textContent = `${launcher.label} (${launcher.id})`;
          row.appendChild(label);

          const input = document.createElement("input");
          input.value = launcher.path || "";
          input.placeholder = "Pfad";
          row.appendChild(input);

          const buttons = document.createElement("div");
          buttons.className = "setButtons";

          const btnBrowse = document.createElement("button");
          btnBrowse.className = "btn";
          btnBrowse.type = "button";
          btnBrowse.textContent = "Browse";
          btnBrowse.onclick = async () => {
            try {
              const r = await api("/api/settings/browse", { method: "POST", body: { kind: "file", title: `${launcher.label} waehlen` } });
              if (r.path) {
                input.value = r.path;
                await api("/api/settings/launcher", { method: "POST", body: { id: launcher.id, path: r.path } });
                showToast(`${launcher.label} gesetzt`);
              } else if (r.unavailable) {
                showToast(r.reason || "Datei-Dialog nicht verfuegbar. Pfad manuell eintragen.");
              }
            } catch (error) {
              showToast(`Browse Fehler: ${error.message || String(error)}`);
            }
          };

          const btnAuto = document.createElement("button");
          btnAuto.className = "btn";
          btnAuto.type = "button";
          btnAuto.textContent = "Auto";
          btnAuto.onclick = async () => {
            try {
              await api("/api/settings/autodetect", { method: "POST", body: { launcherId: launcher.id } });
              await refreshSettingsContent();
              showToast(`${launcher.label} automatisch geprueft`);
            } catch (error) {
              showToast(`Auto Fehler: ${error.message || String(error)}`);
            }
          };

          const btnSave = document.createElement("button");
          btnSave.className = "btn primary";
          btnSave.type = "button";
          btnSave.textContent = "Speichern";
          btnSave.onclick = async () => {
            try {
              await api("/api/settings/launcher", { method: "POST", body: { id: launcher.id, path: input.value } });
              showToast(`${launcher.label} gespeichert`);
            } catch (error) {
              showToast(`Speichern fehlgeschlagen: ${error.message || String(error)}`);
            }
          };

          buttons.appendChild(btnBrowse);
          buttons.appendChild(btnAuto);
          buttons.appendChild(btnSave);
          row.appendChild(buttons);
          el.launchersBox.appendChild(row);
        }

        el.wowBox.textContent = "";
        const folders = settings.wow && settings.wow.folders ? settings.wow.folders : {};
        const keys = ["addons", "logs", "wtf"];
        for (const key of keys) {
          const row = document.createElement("div");
          row.className = "setRow";

          const label = document.createElement("div");
          label.className = "setLabel";
          label.textContent = `WoW ${key}`;
          row.appendChild(label);

          const input = document.createElement("input");
          input.value = folders[key] || "";
          row.appendChild(input);

          const buttons = document.createElement("div");
          buttons.className = "setButtons";

          const btnBrowse = document.createElement("button");
          btnBrowse.className = "btn";
          btnBrowse.type = "button";
          btnBrowse.textContent = "Browse";
          btnBrowse.onclick = async () => {
            try {
              const r = await api("/api/settings/browse", { method: "POST", body: { kind: "folder", title: `WoW ${key} Ordner` } });
              if (r.path) {
                input.value = r.path;
                await api("/api/settings/wow-folder", { method: "POST", body: { key, path: r.path } });
                showToast(`WoW ${key} gesetzt`);
              } else if (r.unavailable) {
                showToast(r.reason || "Ordner-Dialog nicht verfuegbar. Pfad manuell eintragen.");
              }
            } catch (error) {
              showToast(`Browse Fehler: ${error.message || String(error)}`);
            }
          };

          const btnSave = document.createElement("button");
          btnSave.className = "btn primary";
          btnSave.type = "button";
          btnSave.textContent = "Speichern";
          btnSave.onclick = async () => {
            try {
              await api("/api/settings/wow-folder", { method: "POST", body: { key, path: input.value } });
              showToast(`WoW ${key} gespeichert`);
            } catch (error) {
              showToast(`Speichern fehlgeschlagen: ${error.message || String(error)}`);
            }
          };

          buttons.appendChild(btnBrowse);
          buttons.appendChild(btnSave);
          row.appendChild(buttons);
          el.wowBox.appendChild(row);
        }

        const procRow = document.createElement("div");
        procRow.className = "setRow";
        const procLabel = document.createElement("div");
        procLabel.className = "setLabel";
        procLabel.textContent = "WoW Prozessname";
        procRow.appendChild(procLabel);
        const procInput = document.createElement("input");
        procInput.value = settings.wow?.processName || "WowClassic.exe";
        procRow.appendChild(procInput);
        const procButtons = document.createElement("div");
        procButtons.className = "setButtons";
        const procSave = document.createElement("button");
        procSave.className = "btn primary";
        procSave.type = "button";
        procSave.textContent = "Speichern";
        procSave.onclick = async () => {
          try {
            await api("/api/settings/wow-process", { method: "POST", body: { processName: procInput.value } });
            showToast("WoW Prozess gespeichert");
          } catch (error) {
            showToast(`Speichern fehlgeschlagen: ${error.message || String(error)}`);
          }
        };
        procButtons.appendChild(procSave);
        procRow.appendChild(procButtons);
        el.wowBox.appendChild(procRow);

        el.hiddenBox.textContent = "";
        if (!state.hidden.size) {
          const msg = document.createElement("div");
          msg.className = "setLabel";
          msg.textContent = "Keine ausgeblendeten Tiles.";
          el.hiddenBox.appendChild(msg);
        } else {
          const tileMap = new Map(state.tiles.map((t) => [t.id, t]));
          for (const id of Array.from(state.hidden)) {
            const row = document.createElement("div");
            row.className = "setRow";
            const label = document.createElement("div");
            label.className = "setLabel";
            label.textContent = tileMap.get(id)?.label || id;
            row.appendChild(label);
            const btn = document.createElement("button");
            btn.className = "btn";
            btn.type = "button";
            btn.textContent = "Einblenden";
            btn.onclick = async () => {
              state.hidden.delete(id);
              saveSet(LS.hidden, state.hidden);
              renderTiles();
              await refreshSettingsContent();
            };
            row.appendChild(btn);
            el.hiddenBox.appendChild(row);
          }
        }

        setLoggingUi(settings.logging || {});
        try {
          await loadRecentLogs();
        } catch (error) {
          el.logMeta.textContent = `Logs konnten nicht geladen werden: ${error.message || String(error)}`;
          el.logView.textContent = "";
        }
      } catch (error) {
        el.launchersBox.textContent = "";
        const msg = document.createElement("div");
        msg.className = "setLabel";
        msg.textContent = `Konnte Einstellungen nicht laden: ${error.message || String(error)}`;
        el.launchersBox.appendChild(msg);
        el.logMeta.textContent = `Konnte Logs nicht laden: ${error.message || String(error)}`;
        el.logView.textContent = "";
      }
    }

    async function openSettingsDialog() {
      el.tokenInput.value = state.token;
      await refreshSettingsContent();
      if (!el.dlgSettings.open) el.dlgSettings.showModal();
    }

    el.clearQ.addEventListener("click", () => {
      el.q.value = "";
      renderTiles();
    });
    el.q.addEventListener("input", renderTiles);

    el.profileTabs.addEventListener("click", (event) => {
      const btn = event.target.closest("button.tab[data-profile]");
      if (!btn) return;
      state.profile = btn.dataset.profile;
      const pages = pagesForProfile(state.profile);
      state.page = pages[0]?.id || "main";
      localStorage.setItem(LS.profile, state.profile);
      localStorage.setItem(LS.page, state.page);
      renderTiles();
    });

    el.pageTabs.addEventListener("click", (event) => {
      const btn = event.target.closest("button.tab[data-page]");
      if (!btn) return;
      state.page = btn.dataset.page;
      localStorage.setItem(LS.page, state.page);
      renderTiles();
    });

    function clearLongPress() {
      if (state.longPressTimer) clearTimeout(state.longPressTimer);
      state.longPressTimer = null;
      state.longPressTileId = "";
    }

    document.addEventListener("pointerdown", (event) => {
      const btn = event.target.closest("button.tile[data-id]");
      if (!btn) return;
      state.longPressTileId = btn.dataset.id;
      state.longPressTimer = setTimeout(() => {
        state.longPressTimer = null;
        openTileMenuById(state.longPressTileId);
      }, 450);
    });

    document.addEventListener("pointerup", clearLongPress);
    document.addEventListener("pointercancel", clearLongPress);
    document.addEventListener("pointerleave", clearLongPress);
    window.addEventListener("blur", clearLongPress);

    document.addEventListener("pointermove", (event) => {
      if (!state.longPressTimer) return;
      if (Math.abs(event.movementX) + Math.abs(event.movementY) > 8) {
        clearTimeout(state.longPressTimer);
        state.longPressTimer = null;
      }
    });

    document.addEventListener("click", (event) => {
      const btn = event.target.closest("button.tile[data-id]");
      if (!btn || el.dlgTile.open) return;
      runTile(btn.dataset.id);
    });

    document.addEventListener("contextmenu", (event) => {
      const btn = event.target.closest("button.tile[data-id]");
      if (!btn) return;
      event.preventDefault();
      openTileMenuById(btn.dataset.id);
    });

    document.addEventListener("keydown", (event) => {
      const target = event.target;
      if (!(target instanceof HTMLElement)) return;
      const btn = target.closest("button.tile[data-id]");
      if (!btn) return;
      const isContextKey = event.key === "ContextMenu" || (event.shiftKey && event.key === "F10");
      if (!isContextKey) return;
      event.preventDefault();
      openTileMenuById(btn.dataset.id);
    });

    el.btnAdd.addEventListener("click", () => {
      if (!state.token) {
        showToast("Bitte zuerst Token setzen");
        openSettingsDialog();
        return;
      }
      openAddDialog().catch((error) => {
        showToast(`Dialog konnte nicht geoeffnet werden: ${error.message || String(error)}`);
      });
    });

    el.quickProgramAdd.addEventListener("click", async () => {
      try {
        await quickAddProgram(el.quickProgramInput.value);
        el.quickProgramInput.value = "";
      } catch (error) {
        showToast(`Quick-Add fehlgeschlagen: ${error.message || String(error)}`);
      }
    });

    el.quickProgramInput.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        event.preventDefault();
        el.quickProgramAdd.click();
      }
    });

    el.addProfile.addEventListener("change", () => {
      fillPageSelect(el.addProfile.value, el.addPage);
    });
    el.addType.addEventListener("change", async () => {
      updateAddFormVisibility();
      if (el.addType.value === "app") {
        try {
          const programs = await fetchPrograms(el.addTarget.value, 10);
          renderProgramSuggestions(programs);
        } catch {
          renderProgramSuggestions([]);
        }
      }
    });
    el.addIconMode.addEventListener("change", updateAddFormVisibility);

    el.addBrowse.addEventListener("click", async () => {
      const kind = el.addBrowse.dataset.kind || "file";
      try {
        const result = await api("/api/settings/browse", { method: "POST", body: { kind } });
        if (result.path) {
          el.addTarget.value = result.path;
          if (el.addType.value === "app") {
            if (!el.addLabel.value.trim()) el.addLabel.value = inferProgramLabel(result.path);
            renderProgramSuggestions([{ label: inferProgramLabel(result.path), path: result.path, source: "browse" }]);
          }
        } else if (result.unavailable) {
          showToast(result.reason || "Datei-/Ordner-Dialog nicht verfuegbar. Ziel bitte manuell eingeben.");
        }
      } catch (error) {
        showToast(`Browse Fehler: ${error.message || String(error)}`);
      }
    });

    el.addTarget.addEventListener("input", () => {
      if (el.addType.value !== "app") return;
      if (state.addProgramSearchTimer) clearTimeout(state.addProgramSearchTimer);
      state.addProgramSearchTimer = setTimeout(async () => {
        try {
          const programs = await fetchPrograms(el.addTarget.value, 8);
          renderProgramSuggestions(programs);
        } catch {
          renderProgramSuggestions([]);
        }
      }, 220);
    });

    el.addFindProgram.addEventListener("click", async () => {
      try {
        const query = String(el.addTarget.value || "").trim() || String(el.addLabel.value || "").trim();
        if (!query) throw new Error("Bitte Programmname oder Pfad eingeben");
        const splitInput = splitAppTargetInput(query);
        const targetInput = splitInput.target || query;
        const resolved = await resolveProgramInput(targetInput, { allowDirectPathFallback: true });
        el.addTarget.value = resolved;
        if (splitInput.inlineArgs.length) {
          const mergedArgs = [...splitInput.inlineArgs, ...parseArgs(el.addArgs.value)];
          el.addArgs.value = formatArgs(mergedArgs);
        }
        if (!el.addLabel.value.trim()) el.addLabel.value = inferProgramLabel(resolved);
        const programs = await fetchPrograms(query, 8);
        renderProgramSuggestions(programs);
        showToast(`Programm gefunden: ${resolved}`);
      } catch (error) {
        showToast(`Suche fehlgeschlagen: ${error.message || String(error)}`);
      }
    });

    el.addTopPrograms.addEventListener("click", async () => {
      try {
        const programs = await fetchPrograms("", 16);
        renderProgramSuggestions(programs);
      } catch (error) {
        showToast(`Programmliste konnte nicht geladen werden: ${error.message || String(error)}`);
      }
    });

    el.addCancel.addEventListener("click", () => {
      state.editingTileId = "";
      state.editingTileIconData = "";
      el.dlgAdd.close();
    });
    el.dlgAdd.addEventListener("close", () => {
      state.editingTileId = "";
      state.editingTileIconData = "";
      setAddDialogMode(false);
    });

    el.addSave.addEventListener("click", async () => {
      try {
        const type = el.addType.value;
        const profile = el.addProfile.value;
        const page = el.addPage.value;
        const rawTarget = String(el.addTarget.value || "").trim();
        let label = String(el.addLabel.value || "").trim();
        const subtitle = String(el.addSubtitle.value || "").trim();
        if (type === "app" && !label) label = inferProgramLabel(rawTarget);
        if (!profile || !page || !label) throw new Error("Profil, Seite und Titel sind Pflicht");

        const tile = {
          profile,
          page,
          label,
          subtitle,
          type,
          iconMode: el.addIconMode.value,
          icon: "",
          iconData: ""
        };
        if (state.editingTileId) tile.id = state.editingTileId;

        if (tile.iconMode === "emoji") tile.icon = String(el.addIconEmoji.value || "").trim();
        if (tile.iconMode === "image") {
          const uploadedIcon = await readImageDataUrl(el.addIconFile.files && el.addIconFile.files[0]);
          tile.iconData = uploadedIcon || state.editingTileIconData || "";
          if (!tile.iconData) throw new Error("Bitte eine Bilddatei waehlen");
        }

        if (type === "action") {
          tile.action = el.addAction.value;
        } else {
          tile.target = rawTarget;
          if (!tile.target) throw new Error("Ziel fehlt");
        }

        if (type === "url") {
          const normalized = tile.target.includes("://") ? tile.target : `https://${tile.target}`;
          const check = new URL(normalized);
          if (!["http:", "https:"].includes(check.protocol)) throw new Error("Nur http/https erlaubt");
          tile.target = check.toString();
        }

        if (type === "protocol") {
          if (!/^[a-z][a-z0-9+.-]*:[^\s]*$/i.test(tile.target)) {
            throw new Error("Ungueltiges Protocol-Schema");
          }
        }

        if (type === "app") {
          const splitInput = splitAppTargetInput(tile.target);
          tile.target = splitInput.target || tile.target;
          try {
            tile.target = await resolveProgramInput(tile.target, { allowDirectPathFallback: true });
          } catch (error) {
            if (looksLikePathInput(tile.target)) {
              tile.target = unquoteInput(tile.target);
              showToast("Hinweis: Programm konnte nicht auto-aufgeloest werden. Pfad wird direkt gespeichert.");
            } else {
              throw error;
            }
          }
          tile.args = [...splitInput.inlineArgs, ...parseArgs(el.addArgs.value)];
          const startIn = String(el.addStartIn.value || "").trim();
          if (startIn) tile.startIn = startIn;
        }

        await api("/api/tiles/upsert", { method: "POST", body: { tile } });
        el.dlgAdd.close();
        const wasEditing = Boolean(state.editingTileId);
        state.editingTileId = "";
        state.editingTileIconData = "";
        await loadBootstrap();
        showToast(wasEditing ? "Tile aktualisiert" : "Tile gespeichert");
      } catch (error) {
        showToast(`Speichern fehlgeschlagen: ${error.message || String(error)}`);
      }
    });

    el.btnSettings.addEventListener("click", openSettingsDialog);
    el.settingsClose.addEventListener("click", () => el.dlgSettings.close());

    el.saveToken.addEventListener("click", async () => {
      state.token = String(el.tokenInput.value || "").trim();
      localStorage.setItem(LS.token, state.token);
      showToast("Token gespeichert");
      try {
        await loadBootstrap();
        await pollStatus();
      } catch (error) {
        showToast(`Laden fehlgeschlagen: ${error.message || String(error)}`);
      }
    });

    el.testToken.addEventListener("click", async () => {
      state.token = String(el.tokenInput.value || "").trim();
      if (!state.token) {
        showToast("Token fehlt");
        return;
      }
      try {
        await api("/api/health");
        showToast("Token ist gueltig");
      } catch (error) {
        showToast(`Token ungueltig: ${error.message || String(error)}`);
      }
    });

    el.refreshAll.addEventListener("click", async () => {
      try {
        await loadBootstrap();
        await pollStatus();
        showToast("Neu geladen");
      } catch (error) {
        showToast(`Neu laden fehlgeschlagen: ${error.message || String(error)}`);
      }
    });

    el.autoDetectAll.addEventListener("click", async () => {
      try {
        await api("/api/settings/autodetect", { method: "POST", body: {} });
        await refreshSettingsContent();
        showToast("Auto-Erkennung ausgefuehrt");
      } catch (error) {
        showToast(`Auto-Erkennung fehlgeschlagen: ${error.message || String(error)}`);
      }
    });

    el.logsRefresh.addEventListener("click", async () => {
      try {
        await loadRecentLogs();
        showToast("Logs geladen");
      } catch (error) {
        showToast(`Logs laden fehlgeschlagen: ${error.message || String(error)}`);
      }
    });

    el.logLines.addEventListener("change", async () => {
      if (!el.dlgSettings.open || !state.token) return;
      try {
        await loadRecentLogs();
      } catch {
        // ignore on quick line-count changes
      }
    });

    el.logsCopy.addEventListener("click", async () => {
      const text = String(el.logView.textContent || "").trim();
      if (!text) {
        showToast("Keine Logs zum Kopieren");
        return;
      }
      try {
        if (navigator.clipboard?.writeText) {
          await navigator.clipboard.writeText(text);
        } else {
          const tmp = document.createElement("textarea");
          tmp.value = text;
          document.body.appendChild(tmp);
          tmp.select();
          document.execCommand("copy");
          tmp.remove();
        }
        showToast("Logs kopiert");
      } catch (error) {
        showToast(`Kopieren fehlgeschlagen: ${error.message || String(error)}`);
      }
    });

    el.logSave.addEventListener("click", async () => {
      try {
        await api("/api/settings/logging", {
          method: "POST",
          body: {
            enabled: el.logEnabled.value === "true",
            level: String(el.logLevel.value || "INFO").toUpperCase(),
            maxFiles: Number(el.logMaxFiles.value) || 14,
            dir: String(el.logDir.value || "").trim()
          }
        });
        await refreshSettingsContent();
        showToast("Logging gespeichert");
      } catch (error) {
        showToast(`Logging speichern fehlgeschlagen: ${error.message || String(error)}`);
      }
    });

    document.addEventListener("visibilitychange", () => {
      if (document.hidden || !state.token) return;
      pollStatus().catch(() => setApiState("offline", "err"));
      loadBootstrap().catch(() => setApiState("offline", "err"));
    });

    async function init() {
      if (!state.token) {
        setApiState("token?", "");
        setWowState("unknown", "");
        renderTiles();
        openSettingsDialog();
        return;
      }

      try {
        await loadBootstrap();
        await pollStatus();
      } catch (error) {
        showToast(`Init Fehler: ${error.message || String(error)}`);
        setApiState("offline", "err");
      }

      if (state.serverBuild) {
        console.info(`StreamDeck UI ${CLIENT_BUILD} | Server ${state.serverVersion || "?"} (${state.serverBuild})`);
      }

      if (state.pollTimer) clearInterval(state.pollTimer);
      state.bootstrapTick = 0;
      state.pollTimer = setInterval(async () => {
        try {
          await pollStatus();
          if (state.bootstrapTick % 3 === 0) {
            await loadBootstrap();
          }
          state.bootstrapTick += 1;
        } catch {
          setApiState("offline", "err");
        }
      }, 5000);
    }

    init();
  </script>
</body>
</html>
